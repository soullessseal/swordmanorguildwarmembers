<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>名劍山莊-幫戰比對工具</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --bg: #0f172a;
      --card: #ffffff;
      --line: #e2e8f0;
      --green: #dcfce7;
      --red: #fee2e2;
      --text: #0f172a;
      --radius: 0.75rem;
    }
    body {
      background: var(--bg);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 1.25rem;
      font-size: 16px;
    }
    h1 { color: #fff; margin: 0 0 .75rem; }
    .layout {  display: grid;  grid-template-columns: 0.7fr 1.0fr 1.5fr 0.7fr; gap: 1rem;  align-items: flex-start;}
    .panel { background: var(--card); border-radius: var(--radius); padding: 1rem; border: 1px solid rgba(15, 23, 42, 0.05); box-shadow: 0 10px 30px rgba(0,0,0,.04); }
    #allMembersPanel { position: sticky; top: 1rem; z-index: 5; }
    .right-sticky-wrap { position: sticky; top: 1rem; z-index: 6; display: flex; flex-direction: column; gap: .6rem; }
    .right-actions-bar { display: flex; gap: .4rem; justify-content: flex-end; }
    .float-btn { background: #475569; border: none; color: #fff; padding: 0.35rem 0.75rem; border-radius: 999px; font-weight: 600; font-size: 0.78rem; cursor: pointer; white-space: nowrap; }
    .float-btn.secondary { background: #475569; }
    .float-btn.danger { background: #ef4444; }
    .member-search { width: 100%; padding: 0.4rem 0.5rem; border: 1px solid #cbd5e1; border-radius: 0.4rem; margin-bottom: 0.5rem; font-size: 0.85rem; box-sizing: border-box; }
    .role-tabs { display: flex; flex-wrap: wrap; gap: .35rem; margin-bottom: .5rem; }
    .role-tab { padding: 0.25rem 0.6rem; border-radius: 999px; color: #0f172a; font-size: 0.73rem; cursor: pointer; border: 1px solid transparent; user-select: none; white-space: nowrap; }
    .role-tab.active { border: 1px solid #0f172a44; }
    .member-list { border: 1px solid #e2e8f0; border-radius: 0.5rem; padding: 0.4rem; background: #f8fafc; }
    .member-item { display: flex; justify-content: space-between; gap: .35rem; align-items: center; background: #fff; border-radius: .35rem; padding: .3rem .35rem; margin-bottom: .3rem; border: 1px solid #e2e8f0; cursor: grab; }

/*V16.1新增顯示目前幫眾人數*/
.guild-count {
  font-size: 0.78rem;
  color: #64748b;
  margin-left: 0.4rem;
}

    /* 左邊：名字＋技能改成兩欄固定排版 */
.member-left {
  flex: 1 1 auto;
  min-width: 0;
  display: grid;
  grid-template-columns: 6.5em 1fr;   /* ← 調這個寬度，可以微調技能起始位置 */
  column-gap: .4rem;
  align-items: center;
}
/* 名字：如果太長就…省略 */
.member-name {
  font-weight: 700;
  font-size: .9rem;
  color: var(--text);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
/* 技能文字靠左、保持同一行 */
.member-skill {
  font-size: .7rem;
  opacity: .7;
  white-space: nowrap;
}
/* V16.3在技能前面加一個「｜」作為分隔 */
.member-skill::before {
  content: "｜";
  margin: 0 .2rem 0 .2rem;   /* 左右距離可以再微調 */
  color: #cbd5e1;             /* 淺灰色，不會太搶眼 */
}

    .member-actions { display:flex; gap:.25rem; }
    .member-actions button { border:none; background:#e2e8f0; font-size:.65rem; border-radius:.35rem; padding:.25rem .45rem; cursor:pointer; }
    .pagination { display:flex; justify-content:center; gap:.35rem; margin-top:.4rem; }
    .pagination button { border:1px solid #cbd5e1; background:#fff; border-radius:.35rem; font-size:.65rem; padding:.25rem .45rem; cursor:pointer; }
    .pagination select { font-size:.7rem; }
    .add-member-form { margin-top: .35rem; display: none; flex-direction: column; gap: 0.3rem; width: 100%; }
    .add-member-form input, .add-member-form select { padding: 0.35rem 0.4rem; border: 1px solid #cbd5e1; border-radius: 0.4rem; font-size: 0.78rem; width: 100%; box-sizing: border-box; }

    .team-block { border: 1px solid var(--line); border-radius: 0.5rem; margin-bottom: 1rem; overflow: hidden; }
    .team-head { color: #fff; padding: 0.4rem 0.6rem; display: flex; justify-content: space-between; align-items: center; font-size: 0.9rem; gap: .5rem; }
    .team-head-left { display:flex; align-items:center; gap:.4rem; }
    .team-tag-select { font-size: .78rem; font-weight: 700; border-radius: .35rem; border: none; padding: .2rem .45rem; background: rgba(255,255,255,0.95); color: #0f172a; line-height: 1.2; cursor: pointer; }
    .team-tag-select option { font-size: .78rem; font-weight: 600; color: #0f172a; }
    .team-tag-label { background: rgba(255,255,255,0.95); color: #0f172a; font-size: .78rem; font-weight: 700; border-radius: .35rem; padding: .2rem .55rem; }
    .head-add-btn { background: rgba(255,255,255,0.12); border: 1px solid rgba(255,255,255,0.25); color: #fff; font-size: .65rem; border-radius: .35rem; padding: .2rem .45rem; cursor: pointer; }
    .head-add-btn.disabled { opacity:.35; cursor:not-allowed; }

    .squads { display: flex; flex-wrap: nowrap; border-top: 1px solid var(--line); width: 100%; }
    .squad { border-left: 1px solid var(--line); padding: 0.4rem 0.4rem 0.75rem; position: relative; flex: 1 1 auto; min-width: 0; }
    .squad:first-child { border-left: none; }
    .squad-title { background: #f8fafc; text-align: center; font-weight: 700; padding: 0.3rem; border-radius: 0.25rem; margin-bottom: 0.4rem; border: 1px solid #e2e8f0; font-size: 0.78rem; }
    .squad-del-btn { position: absolute; top: 6px; right: 6px; width: 22px; height: 22px; border: none; border-radius: 999px; background: #ef4444; color: #fff; font-size: 14px; line-height: 22px; text-align: center; cursor: pointer; padding: 0; }
    @media (max-width: 600px) { .squad-del-btn { top: 4px; right: 4px; width: 20px; height: 20px; line-height: 20px; font-size: 13px; } }

    /* V16.2本週名單底部的切換圓點：桌機＋手機都顯示 */
    .team-dots {
    display: flex;
    gap: 8px;
    justify-content: center;
    margin-top: .5rem;
    }

    /*V16.2滑動動畫*/
    /* 右邊滑進來 */
@keyframes teamSlideFromRight {
  from {
    opacity: 0;
    transform: translateX(40px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}
/* 左邊滑進來 */
@keyframes teamSlideFromLeft {
  from {
    opacity: 0;
    transform: translateX(-40px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}
/* 根據 JS 加上的 class 播放不同方向的 slide */
#thisWeek .team-block.slide-from-right {
  animation: teamSlideFromRight .25s ease-out;
}
#thisWeek .team-block.slide-from-left {
  animation: teamSlideFromLeft .25s ease-out;
}



    /* V16讓標題與儲存按鈕排在同一行 */
.header-row {
  display: flex;
  align-items: center;
  gap: .75rem;           /* 標題跟按鈕之間留一點距離 */
  margin-bottom: 0.75rem;
  /* 把這行拿掉：justify-content: space-between; */
}
/* 桌面版儲存按鈕的樣式 */
.save-btn-desktop {
  background: #ef4444;
  color: #fff;
  padding: 0.45rem 1.1rem;
  border-radius: 999rem;
  font-size: 0.95rem;
  margin-top: -0.73rem;
  cursor: pointer;
  border: none;
}
/* 手機版不顯示桌面儲存按鈕 */
@media (max-width: 900px) {
  .save-btn-desktop {
    display: none;
  }
}
/* 電腦版不顯示手機儲存按鈕 */
@media (min-width: 901px) {
  .right-actions-bar {
    display: none !important;
  }
}

/*V16.1手機翻頁恢復*/
   @media (max-width: 900px) {
  /* 只控制本週名單的團隊翻頁 */
  #thisWeek {
    overflow-x: visible;
    white-space: normal;
  }
  /* 外層包團的容器 */
  #thisWeek .teams-wrap {
    position: relative;
    width: 100%;
  }
  /* 每一個團 block：手機時預設隱藏 */
  #thisWeek .team-block {
    width: 100%;
    display: none;
  }
  /* 只有 active 的那一團會顯示 */
  #thisWeek .team-block.active {
    display: block;
  }
  /* 團裡面的隊伍排版維持原本的行為 */
  #thisWeek .team-block .squads {
    overflow-x: visible;
    width: 100%;
  }
  #thisWeek .team-block .squad {
    min-width: 0;
  }
}

/* ✅ V16.2所有裝置共用的小圓點樣式（桌機＋手機） */
.team-dot {
  width: 10px;
  height: 10px;
  border-radius: 999px;
  border: none;
  padding: 0;
  opacity: 0.5;
  cursor: pointer;
  transition: transform .18s ease, box-shadow .18s ease, opacity .18s ease;
}
.team-dot.active {
  opacity: 1;
  transform: scale(1.3);
  box-shadow: 0 0 0 1px rgba(15,23,42,.25);
}


    .member-row { display:flex; gap:.25rem; margin-bottom:.3rem; }
    /* 針對「本週名單」內的小隊，微調每一列的上下距離 */
#thisWeek .squad .member-row:nth-child(odd) {
  margin-bottom: 0.2rem;  /* 名字列 → 跟技能靠近一點 */
}
#thisWeek .squad .member-row:nth-child(even) {
  margin-bottom: 0.5rem;  /* 技能列 → 和下一位成員保持原本間距 */
}

    .member-row input { width: 100%; font-size: 0.78rem; padding: 0.3rem 0.35rem; border: 1px solid #cbd5f5; border-radius: 0.25rem; box-sizing: border-box; font-weight: 700; }
    .readonly-skill { background:#e2e8f0; }
    .locked-input { /*V14.8修改，滑鼠完全不能互動*/
  background: #e2e8f0;
  pointer-events: none;     /* 滑鼠點不到 */
  user-select: none;        /* 不能選取文字 */
  caret-color: transparent; /* 不顯示輸入游標 */
}

/* V17.4跑馬燈：只會套在被 JS 加上 .marquee 的欄位 */
#thisWeek .member-row input.marquee {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: clip;
  animation: tw-marquee 3s linear infinite;
}
/* V17.4利用 text-indent 做左右滑動 */
@keyframes tw-marquee {
  0%   { text-indent: 0; }
  100% { text-indent: -100%; }
}
@keyframes tw-marquee {
  0%   { text-indent: 0; }
  10%  { text-indent: 0; }        /* 停一下 */
  100% { text-indent: -100%; }
}
#thisWeek .member-row input.marquee {
  animation: tw-marquee 5s linear infinite;
}

/* 幫會職位比對：幫眾在職位裡，但沒出現在本週 → 紅色膠囊 */
.position-tag.guild-missing-in-week {
  background: #fee2e2 !important;   /* 淺紅底 */
  color: #b91c1c !important;        /* 深紅字 */
}

/* 幫會職位比對：本週有上場，但沒掛幫眾 → 綠色膠囊（出現在學徒欄位） */
.position-tag.guild-from-week-only {
  background: #3A9267 !important;   /* 淺綠底 */
  border-color: #14532d; /* 再深一點的邊框 */
  color: #ffffff !important;        /* 深綠字 */
  text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
}

/* V17新增學徒標籤狀態 icon */
.tag-status-icon {
  margin-left: .25rem;
  font-size: 0.78rem;
}
/* 學徒欄：不確定狀態的標籤也要顯示成可點選 */
.position-tag.guild-from-week-unsure {
  cursor: pointer;
}
/* 本週狀態＝未上線 → 學徒欄用白色標籤，不能點選交換 */
.position-tag.guild-from-week-absent {
  background: #ffffff !important;
  cursor: pointer;   /* V17.2改成可點選 */ 
}


/* 紅／綠標籤可以點選 */
.position-tag.guild-missing-in-week,
.position-tag.guild-from-week-only {
  cursor: pointer;
}

/* 被選中的狀態 */
.position-tag.guild-selected {
  box-shadow: 0 0 0 2px #0ea5e9;
  transform: translateY(-1px);
}

/*V16新增幫眾添加成員按鈕*/
.guild-add-btn {
  margin-left: .35rem;
  width: 1.2rem;
  height: 1.2rem;
  border-radius: 999px;
  border: none;
  background: #0ea5e9;
  color: #ffffff;
  font-weight: 900;
  font-size: .78rem;
  line-height: 0;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  transition: transform .12s ease, box-shadow .12s ease, background .12s ease;
  /* 保險：就算有誤上職業色，也蓋掉左邊色條 */
  border-left: none !important;
}
.guild-add-btn:active {
  transform: translateY(0);
  box-shadow: 0 2px 8px rgba(34,197,94,0.25);
}

/* V16.2本週名單：一律一次只顯示一團，由 .active 控制 */
#thisWeek .teams-wrap {
  position: relative;
  width: 100%;
}
#thisWeek .team-block {
  width: 100%;
  display: none;      /* 預設都隱藏 */
}
#thisWeek .team-block.active {
  display: block;     /* 只有 .active 那團顯示 */
}

/* V17.2新增，本週名單上方：狀態說明列 */
.week-legend {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  gap: 6px;
  font-size: .78rem;
  color: #64748b;
  margin-bottom: 0.4rem;
}
/* 小示意框，長得像縮小版的本週欄位 */
.week-pill {
  display: inline-flex;
  align-items: center;
  padding: 0.18rem 0.45rem;
  border-radius: 0.25rem;
  font-size: 0.75rem;
  font-weight: 700;
  box-sizing: border-box;
}
/* 已入組：沿用 status-present 的深綠 */
.week-pill.week-present {
  background: #3A9267;
  border: 1px solid #14532d;
  color: #ffffff;
}
/* 不確定：沿用 status-unsure 的淺綠 + 自帶 ? 圓圈 */
.week-pill.week-unsure {
  position: relative;
  background: #6CC499;
  border: 1px solid #46a769;
  color: #ffffff;
  padding-right: 1.6rem; /* 右邊留空給 ? 圓圈 */
}
.week-pill.week-unsure::after {
  content: "？";
  position: absolute;
  right: 4px;
  top: 50%;
  transform: translateY(-50%);
  width: 14px;
  height: 14px;
  border-radius: 999px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.7rem;
  font-weight: 700;
  background: #bbf7d0;
  color: #3A9267;
  border: 2px solid #3A9267;
}
/* 未上線：沿用 status-absent 的灰色樣式 */
.week-pill.week-absent {
  background: #e5e7eb;
  border: 1px solid #d1d5db;
  color: #6b7280;
}
.week-legend-tip {
  margin-left: 4px;
}



    #subsList { display:flex; flex-direction:column; gap:.25rem; }
    .substitute-row { display: grid; grid-template-columns: 1fr 1fr auto; grid-template-rows: auto auto; gap: 0.25rem; align-items: center; border: 1px solid #e2e8f0; border-radius: 0.35rem; padding: 0.25rem; background: #f8fafc; }
    .substitute-row input { width: 100%; padding: 0.25rem 0.3rem; border-radius: 0.25rem; border: 1px solid #e2e8f0; font-size: 0.78rem; font-weight: 700; box-sizing: border-box; }
    .del-btn { background: #ef4444; color: #fff; border: none; border-radius: 0.35rem; padding: 0.22rem 0.45rem; font-size: 0.7rem; cursor: pointer; }
    .substitute-row span.sub-status { grid-column: 1 / span 3; font-size: 0.7rem; min-height: 1.2rem; }
    .drag-preview { position: fixed; pointer-events: none; z-index: 9999; padding: 0.2rem 0.5rem; background: #0f172a; color: #fff; font-size: 0.65rem; border-radius: 999px; }

    #thisWeek { position: relative; }
    #downloadBtn { position: absolute; top: 1rem; right: 1rem; background: #0f766e; }

    #loginModal { position: fixed; inset: 0; background: rgba(15,23,42,.5); display: none; align-items: center; justify-content: center; z-index: 99999; }
    #loginModal .modal-card { background: #fff; border-radius: .75rem; padding: 1.2rem 1.4rem; width: 280px; box-shadow: 0 20px 40px rgba(0,0,0,.12); }
    #loginModal h3 { margin: 0 0 .5rem; font-size: 1.05rem; }
    #loginModal input { width: 100%; margin-bottom: .5rem; padding: .35rem .4rem; border: 1px solid #cbd5e1; border-radius: .4rem; box-sizing: border-box; /* ★ 加這行 */}

    /* V18.2 本週名單移動成員的小提示泡泡 */
.week-toast {
  position: absolute;
  background: rgba(15, 23, 42, 0.95);
  color: #f1f5f9;
  padding: 0.35rem 0.65rem;
  border-radius: 0.45rem;
  font-size: 0.75rem;
  white-space: nowrap;
  z-index: 9999;
  pointer-events: none;
  opacity: 0;
  transform: translate(-50%, -6px);
  transition: opacity .15s ease, transform .15s ease;
}
.week-toast.show {
  opacity: 1;
  transform: translate(-50%, -12px); /* 往上浮一點 */
}



    .outline-dabai { outline: 2px solid #a855f7; outline-offset: 2px; }
    .outline-baoan { outline: 2px solid #ef4444; outline-offset: 2px; }
    .outline-stitch { outline: 2px solid #38bdf8; outline-offset: 2px; }

    #memberPicker { position: absolute; background: #fff; border: 1px solid #cbd5e1; border-radius: .5rem; box-shadow: 0 15px 30px rgba(15,23,42,.12); width: 220px; display: none; z-index: 9999; padding: .4rem; overflow: hidden; }
    #memberPicker input { width: 100%; margin-bottom: .35rem; padding: .3rem .4rem; border: 1px solid #cbd5e1; border-radius: .35rem; box-sizing: border-box; }
    #memberPicker .picker-list { max-height: 180px; overflow-y: auto; }
    #memberPicker .picker-item { padding: .25rem .2rem; border-radius: .35rem; cursor: pointer; font-size: .75rem; }
    #memberPicker .picker-item:hover { background: #e2e8f0; }

    @media (max-width: 1300px) {
      .layout { grid-template-columns: 1fr; }
      #allMembersPanel, #guildPositions, .right-sticky-wrap { position: static; }
      #downloadBtn { position: absolute; top: 1rem; right: 1rem; margin-bottom: 0; }
    }
    
    input.skill-has { background: #FFFFDB; color: #0f172a; font-weight: 600; }
    /* 只把替補列的 skill-has 顏色還原成一般輸入框 */
  #subsList .substitute-row .sub-skill.skill-has {
  background: #ffffff;    /* 或 transparent，看你喜歡 */
  color: #0f172a;
  font-weight: 600;
  }


/* ✅ V14.9鎖定本週名單的技能欄位：不能點、不能選字、沒有游標 */
#thisWeek .member-row input[data-role="skill"] {
  pointer-events: none;
  user-select: none;
  caret-color: transparent;
}

/*V17學徒狀態標籤*/
.position-tag .tag-status-icon {
  margin-left: .25rem;
  font-size: 0.7rem;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 1.1em;
  height: 1.1em;
  border-radius: 999px;
  border: 1px solid currentColor;
  line-height: 1;
}

/* ★ 學徒標籤：未上線（absent） */
.position-tag.guild-from-week-absent .tag-status-icon {
  background: #959eaf;    /* 深色底 */
  color: #ffffff;         /* 白字 */
  border: 2px solid #959eaf;
}
/* ★ 學徒標籤：不確定（unsure） */
.position-tag.guild-from-week-unsure .tag-status-icon {
  background: #6CC499;    
  color: #ffffff;       
  border: 2px solid #6CC499;}



/* V17.1 本週名單：確認參戰／不確定／未上線 */
/* 未上線（absent）＝灰色、像 disabled */
#thisWeek .member-row.status-absent input[data-role="name"],
#thisWeek .member-row.status-absent + .member-row input[data-role="skill"] {
  background: #e5e7eb; /* bg-gray-200 */
  border-color: #d1d5db; /* border-gray-300 */
  color: #6b7280; /* text-gray-500 */
  opacity: 0.6;
}
/* V17.2修改確認參戰（present）＝較深的實心綠色、有點浮起來的按鈕感 */
#thisWeek .member-row.status-present input[data-role="name"],
#thisWeek .member-row.status-present + .member-row input[data-role="skill"],
#thisWeek .member-row.status-late input[data-role="name"],
#thisWeek .member-row.status-late + .member-row input[data-role="skill"] {
  background: #3A9267;   /* 比原本更深一階的綠 */
  border-color: #14532d; /* 再深一點的邊框 */
  color: #ffffff;
  text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
}
/* V17.2不確定（unsure）＝比確認參戰更淺一階的綠底＋白字 */
#thisWeek .member-row.status-unsure input[data-role="name"],
#thisWeek .member-row.status-unsure + .member-row input[data-role="skill"] {
  background: #6CC499;   /* 淺一階的實心綠 */
  border-color: #46a769; /* 邊框略深，保留層次感 */
  color: #ffffff;        /* 白字，跟「保安」那顆一樣視覺重量 */
  text-shadow: 0 0 5px rgba(6, 78, 11, 0.7);
}



/* ===============================
   V17.1 本週名單狀態圖示（最新版）
   保留「圓圈包符號」的風格
   =============================== */
/* 只有 late / unsure 顯示圖示（absent / present 不顯示） */
#thisWeek .member-row.status-unsure {
  position: relative;
}
/* 圓圈基底（統一樣式） */
#thisWeek .member-row.status-unsure::after {
  content: "？";
  position: absolute;
  right: 6px;
  top: 50%;
  transform: translateY(-50%);
  width: 14px;
  height: 14px;
  border-radius: 999px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.7rem;
  font-weight: 700;
  background: #bbf7d0;    /* 淺綠底 */
  color: #3A9267;         /* 深綠字 */
  border: 2px solid #3A9267;
}

    
    /* V14.9 手機版：欄位字體縮一點，讓最長 7 個字不被吃掉 */
@media (max-width: 900px) {
  /* 本週成員名稱 */
  #thisWeek .member-row input[data-role="name"],
  #subsList .substitute-row .sub-name {
    font-size: 13px;
    padding: 0.24rem 0.24rem;
  }
  /* 本週技能欄位 */
  #thisWeek .member-row input[data-role="skill"],
  #subsList .substitute-row .sub-skill {
    font-size: 11px;
    padding: 0.20rem 0.24rem;
  }
  /* 左側「全部成員」搜尋＆浮層搜尋，維持原本視覺＋16px 防止放大 */
  #memberSearch,
  #pickerSearch {
    font-size: 0.8rem;
  }
  #memberSearch:focus,
  #pickerSearch:focus {
    font-size: 16px;
  }
    /* ✅ iOS 專用：調整 .ios-zoom-fix，讓框框不要縮小 */
   #thisWeek .member-row input[data-role="name"].ios-zoom-fix,
  #subsList .substitute-row .sub-name.ios-zoom-fix {
    font-size: 16px !important;  /* 只靠字體 16px 來擋 iOS 放大 */
  }

}

    /* 手機板底部按鈕 */
    @media (max-width: 900px) {
      .right-actions-bar {
        position: fixed;
        bottom: 1rem;
        left: 3rem;
        right: 3rem;
        background: rgba(15, 23, 42, 0.95);
        padding: .4rem .6rem;
        display: flex;
        gap: .5rem;
        justify-content: space-between;
        z-index: 9999;
        border-radius: 3rem;
        height: 2.5rem;
        align-items: center;
      }
      .right-actions-bar .float-btn { flex: 1; padding: .4rem .6rem; font-size: .85rem; font-weight: 600; border-radius: .999rem; }
      body { padding-bottom: 5.2rem; }
      .right-sticky-wrap { position: static; }
    }

    .panel-title-row { display: flex; align-items: center; justify-content: space-between; gap: .5rem; margin-bottom: .3rem; }
    #downloadBtn { position: static; }


/* V16幫會職位欄位：也做成 sticky，跟左邊一樣貼在頂部 */
#guildPositions {
  position: sticky;
  top: 1rem;
  z-index: 5;
  display: flex;
  flex-direction: column;
  gap: .5rem;
}

@media (max-width: 1300px) {
  #guildPositions {
    position: static;
    top: auto;
  }
}
.guild-pos-note {
  font-size: .78rem;
  color: #64748b;
  margin: 0;
}
.guild-pos-grid {
  display: grid;
  grid-template-columns: 1fr auto 1fr;  /* 左幫眾 / 中間按鈕 / 右學徒 */
  gap: .75rem;
  align-items: stretch;
}
.guild-swap-wrap {
  display: flex;
  align-items: center;
  justify-content: center;
}
.guild-swap-btn {
  width: 2.4rem;
  height: 2.4rem;
  border-radius: 999px;
  border: none;
  background: #0ea5e9;
  color: #fff;
  font-size: 1.2rem;
  font-weight: 700;
  cursor: pointer;
  box-shadow: 0 10px 20px rgba(15,23,42,.25);
}


/* ─────────── V18桌機版：X 不顯示，維持原本 panel ─────────── */
.guild-header-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: .5rem;
  margin-bottom: .3rem;
}
.guild-close-btn {
  display: none;              /* 桌機不顯示 */
}
/* ─────────── V18手機版：幫會職位變 bottom sheet ─────────── */
@media (max-width: 900px) {

  /* 手機版 X 按鈕：縮小一點再微微往上提 */
  #guildPositions .guild-close-btn {
    display: inline-flex;
    width: 24px;          /* 原本是 28px，可再微調 */
    height: 24px;
    border-radius: 999px;
    align-items: center;
    justify-content: center;
    padding: 0;
    font-size: 2rem;
    line-height: 0;
    color: #6b7280;
    border: none;
    background: transparent;
    cursor: pointer;
    position: relative;
    top: -2px;            /* ⭐ 如果還覺得低，可以改成 -2px 試試 */
  }
  /* 整個幫會職位 panel 做成 bottom sheet */
  #guildPositions {
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0;
    max-height: 80vh;
    transform: translateY(100%);      /* 預設收起來 */
    transition: transform .25s ease-out;
    margin: 0;
    border-radius: 16px 16px 0 0;
    box-shadow: 0 -8px 24px rgba(15,23,42,.45);
    z-index: 9998;
  }
  #guildPositions.is-open {
    transform: translateY(0);         /* 展開 */
  }
  /* 上方灰色拉條（只在手機版顯示） */
  .guild-drawer-header {
    padding: .6rem 0 .3rem;
    display: flex;
    justify-content: center;
  }
  .guild-drawer-grip {
    width: 44px;
    height: 4px;
    border-radius: 999px;
    background: #cbd5e1;
  }
  /* 外框不用那麼高，最低高度一起壓低一點 */
  .guild-box {
    min-height: 7rem;
  }
}
/* 手機版時：底部半透明背景（在 JS 裡動態插入 .guild-backdrop） */
.guild-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(15,23,42,.35);
  z-index: 9990;
}


/*V17.4新增修改交換按鈕大小*/
@media (max-width: 900px) {
  .guild-swap-btn {
    width: 1.7rem;
    height: 1.7rem;
    font-size: 1rem;   /* 裡面的 ⇄ 不會太大 */
  }
}
.guild-swap-btn:disabled {
  opacity: .35;
  cursor: not-allowed;
  box-shadow: none;
}
.guild-col {
  display: flex;
  flex-direction: column;
  gap: .4rem;
}
.guild-col-title {
  font-size: 1rem;
  font-weight: 700;
  color: #0f172a;
}

/* ★ 一個大框，裡面自動排標籤 */
.guild-box {
  min-height: 96px;
  border-radius: .75rem;
  border: 1px dashed #cbd5e1;
  padding: .4rem .55rem;
  box-sizing: border-box;
  background: #f8fafc;
  /* 直向排版：一列一個標籤 */
  display: flex;
  flex-direction: column;
  flex-wrap: nowrap;
  align-items: stretch;
  gap: .25rem;
}

/* 空的大框顯示淡淡提示文字（可選） */
.guild-box.empty::before {
  content: " ";
  font-size: .75rem;
  color: #94a3b8;
}

/* 成員標籤 */
.position-tag {
  display: inline-flex;
  align-items: center;
  padding: .18rem .45rem;
  border-radius: 999px;
  background: #ffffff;
  border: 1px solid #cbd5e1;
  font-size: .85rem;
  font-weight: 700;
  max-width: 100%;
  box-sizing: border-box;
  letter-spacing: -0.02em;
  width: 100%;                 /* 撐滿整列 */
  justify-content: space-between;/* 文字在左，叉叉靠右 */
}
/* 刪除按鈕（叉叉） */
.position-tag-remove {
  margin-left: auto;           /* 往最右邊貼 */
  border: none;
  background: transparent;
  width: 1.1rem;
  height: 1.1rem;
  font-size: 1rem;             /* 叉叉變大 */
  line-height: 1;
  cursor: pointer;
  padding: 0;
  color: #64748b;
  display: flex;
  align-items: center;
  justify-content: center;
}
.position-tag-remove:hover {
  color: #ef4444;
}

/* RWD：手機版幫會職位欄位改成上下排列 */
@media (max-width: 900px) {
  /* 手機版幫會職位：允許標籤並排 */
  .guild-box {
    flex-direction: row;
    flex-wrap: wrap;
    align-items: flex-start;
  }
  .position-tag {
    width: auto;          /* 不要撐滿整列，改成膠囊 */
    flex: 0 1 auto;
  }
  /*V17.4修改手機標籤字大小*/
  .position-tag,
  .position-tag .tag-name {
    font-size: 0.85rem;  /* 你可以改成 0.7rem、0.65rem 等 */
  }
  /* 如果覺得 X 按鈕也太大，可以一起縮 */
  .position-tag .tag-close {
    font-size: 0.7rem;
  }
    /* 手機版幫眾／學徒欄位高度再矮一點，改用內部滾動 */
  #guildBattleBox,
  #guildPendingBox {
    max-height: 17rem !important;
    overflow-y: auto;
  }
}


  /* 電腦幫眾欄：最多顯示約 15 個高度，其餘用滾輪 */
#guildBattleBox {
  max-height: 26rem;   /* 可自行微調，約 15 個標籤高度 */
  overflow-y: auto;
}


/* ★ 讓全部成員名單的技能前面出現｜ */
#allMembersPanelOuter .member-row .skill-hint::before,
.all-members-list .member-row .skill-hint::before {
  content: "｜";             /* 分隔符號 */
  color: #94a3b8;            /* 淺灰色 */
  margin-right: 6px;         /* 與技能距離 */
  font-weight: 500;
}

/*V17.2學徒旁註解*/
/* V17.4讓幫眾 / 學徒 標題＋說明分成兩行 */
.guild-apprentice-title-row {
  display: flex;
  flex-direction: column; /* ← 重點：上下排列，而不是左右 */
  gap: 0.3rem;
}
.guild-title-subrow {
  display: flex;
  align-items: center;
  gap: .4rem;
  flex-wrap: nowrap;
}

.guild-apprentice-title {
  font-size: 18px;
  font-weight: 600;
  color: #0f172a;
}
/* 學徒旁邊的小圖示說明，用跟標籤一樣的 ! / ？ 圓圈 */
.appr-legend {
  display: flex;
  align-items: center;
  gap: 4px; /*學徒:不確定與為上線之間的距離*/
  font-size: 13px;
  color: #475569;
  flex-wrap: nowrap;   /* ❗ 強制不換行 */
  white-space: nowrap; /* ❗ 保證文字不會斷行 */
}
.appr-status {
  display: inline-flex;
  align-items: center;
  gap: 1px; /*不確定與未上線狀態與圖示之間的距離*/
}
/* 讓 legend 內的 icon 跟標籤上那顆一樣大小 */
.appr-legend .tag-status-icon {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 1.1em;
  height: 1.1em;
  border-radius: 999px;
  font-size: 0.7rem;
  font-weight: 700;
  border: 2px solid currentColor;
  line-height: 1;
}
/* 未出席（同 guild-from-week-absent 樣式） */
.appr-legend .tag-status-icon.appr-absent {
  background: #959eaf;
  color: #ffffff;
  border-color: #959eaf;
}
/* 不確定（同 guild-from-week-unsure 樣式） */
.appr-legend .tag-status-icon.appr-unsure {
  background: #6CC499;
  color: #ffffff;
  border-color: #6CC499;
}

/* V17.4手機版調整「不確定」問號大小與位置 */
@media (max-width: 900px) {
  /* 手機：不確定的問號貼在右上角、縮小一點 */
  #thisWeek .member-row.status-unsure::after {
    width: 8px;
    height: 8px;
    font-size: 0.5rem;
    top: 1px;          /* 貼近欄位上緣，不會撞到上面分隔線 */
    right: 1px;        /* 稍微往內縮一點 */
    transform: none;   /* 取消 50% 位移，改用固定 top */
  }
  /* 讓文字不要被右上角問號蓋到，右側多留一點 padding */
  #thisWeek .member-row.status-unsure input[data-role="name"] {
    padding-right: 0.3rem;
  }
}

/*V18.3新增，讀取樣式*/
.loading-mask {
  position: fixed;
  inset: 0;
  background: rgba(15, 23, 42, 0.45); /* 深色半透明 */
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  transition: opacity .12s;
}
.loading-mask img {
  width: 64px;
  height: 64px;
}
.loading-mask.show {
  display: flex;
}



/* 待刪V19：暫時隱藏桌機 / 手機的「儲存」按鈕，保留位置給之後的登入/登出 */
#saveBtn,
#mobileSaveBtn,
.right-actions-bar [data-action="save"] {
  display: none !important;
}


  </style>


<!-- Firebase compat 版本（適合一般 HTML 使用） -->
<script src="https://www.gstatic.com/firebasejs/12.6.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore-compat.js"></script>
<script>
  // 你的 Firebase config（可直接使用）
  const firebaseConfig = {
    apiKey: "AIzaSyCpEk7Kx_IaFYIfgGcJtsPjggXS6xk_dKI",
    authDomain: "swordmanorguildwarmembers.firebaseapp.com",
    projectId: "swordmanorguildwarmembers",
    storageBucket: "swordmanorguildwarmembers.firebasestorage.app",
    messagingSenderId: "78380387762",
    appId: "1:78380387762:web:ee56abb3fe639f32d728ab",
    measurementId: "G-8GQC3GZDY9"
  };
  // 初始化 Firebase
  firebase.initializeApp(firebaseConfig);
  // Firestore 物件（我們等一下要用這個）
  const db = firebase.firestore();
  // 這是資料庫中的「這份幫戰名單的位置」
  // 你要多人共用就用固定位置，例如 "default-room"
  const ROOM_ID = "default-room";
  // 指向 Firestore 文件的引用
  const stateDocRef = db.collection("guildBattleStates").doc(ROOM_ID);
  // ★ V20：把本週名單拆成四份獨立文件（掛在同一個 ROOM_ID 底下）
const teamDocRefs = {
  "進攻":  stateDocRef.collection("teams").doc("offense"),
  "拆塔":  stateDocRef.collection("teams").doc("tower"),
  "機動":  stateDocRef.collection("teams").doc("mobile"),
  "防守":  stateDocRef.collection("teams").doc("defence")
};

</script>


</head>
<body>
  <div class="header-row">
    <h1>名劍山莊-幫戰比對工具</h1>
    <button id="saveBtn" class="save-btn-desktop" onclick="requestSave()">儲存</button>
  </div>

  <div class="layout">
    <!-- 左側：全部成員 -->
    <div class="panel" id="allMembersPanel">
      <h3>全部成員名單</h3>
      <input id="memberSearch" class="member-search" placeholder="搜尋成員名或技能..." oninput="renderMemberList(); saveState();" />
      <div class="role-tabs" id="roleTabs"></div>
      <div class="member-list" id="memberList"></div>
      <div class="pagination">
        <button onclick="prevPage()">◀</button>
        <select id="pageSelect" onchange="jumpPage(this.value)"></select>
        <button onclick="nextPage()">▶</button>
      </div>
      <div style="margin-top:.5rem;">
        <button class="float-btn secondary" style="background:#475569;" onclick="toggleAddMember()">＋ 新增成員</button>
        <div class="add-member-form" id="addMemberForm">
          <input id="newName" placeholder="成員名稱" />
          <select id="newJob">
            <option value="">選擇職業</option>
            <option value="九靈">九靈</option>
            <option value="鐵衣">鐵衣</option>
            <option value="素問">素問</option>
            <option value="龍吟">龍吟</option>
            <option value="神相">神相</option>
            <option value="碎夢">碎夢</option>
            <option value="血河">血河</option>
          </select>
          <input id="newSkill" placeholder="成員技能（可不填）" />
          <button class="float-btn" style="width:100%;text-align:center;" onclick="addMember()">確認新增</button>
        </div>
        <!-- ★ 新增：滿員提示文字 -->
  <p id="memberLimitMsg" style="display:none;font-size:.7rem;color:#b91c1c;margin-top:.25rem;">
    目前已滿員，請移除離開的成員後再新增。
      </div>
    </div>

 <!-- V18修改幫會職位欄位 -->
<div class="panel" id="guildPositions">
  <!-- ⬆︎ 手機版 bottom sheet 的灰色拉條 -->
  <div class="guild-drawer-header">
    <div class="guild-drawer-grip"></div>
  </div>

  <!-- 標題 + 手機版關閉鈕 -->
  <div class="guild-header-row">
    <h3>幫會職位</h3>
    <button type="button" class="guild-close-btn" onclick="closeGuildDrawer()">⨯
    </button>
  </div>

  <p class="guild-pos-note">比對尚未更換職位的成員。</p>

  <div class="guild-pos-grid">
    <!-- V17.4可參戰幫眾 -->
    <div class="guild-col" data-type="battle">
      <div class="guild-apprentice-title-row">
        <div class="guild-col-title">幫眾</div>
        <div class="guild-title-subrow">
          <button class="guild-add-btn" onclick="openGuildAddPicker(this)">＋</button>
          <span id="guildCountLabel" class="guild-count">0/60</span>
        </div>
      </div>
      <div class="guild-box" id="guildBattleBox"
           ondragover="allowDrop(event)"
           ondrop="dropMember(event)"></div>
    </div>

    <!-- 中間交換按鈕 -->
    <div class="guild-swap-wrap">
      <button id="guildSwapBtn"
              type="button"
              class="guild-swap-btn"
              onclick="swapSelectedGuildMembers()"
              disabled>⇄</button>
    </div>

    <!-- 待上架學徒 -->
    <div class="guild-col" data-type="pending">
      <div class="guild-apprentice-title-row">
        <div class="guild-col-title">學徒</div>
        <div class="guild-title-subrow appr-legend">
          <span class="appr-status">
            <span class="tag-status-icon appr-unsure">？</span> 不確定
          </span>
          <span class="appr-status">
            <span class="tag-status-icon appr-absent">！</span> 未上線
          </span>
        </div>
      </div>
      <div class="guild-box" id="guildPendingBox"
           ondragover="allowDrop(event)"
           ondrop="dropMember(event)"></div>
    </div>
  </div>
</div>


    <!-- 本週 -->
    <div class="panel" id="thisWeek">
      <div class="panel-title-row">
        <h3>本週名單</h3>
        <button id="downloadBtn" class="float-btn secondary" onclick="downloadThisWeekImage()">下載圖片</button>
      </div>
      
      <div class="week-legend">
      <span class="week-pill week-present">已入組</span>
      <span class="week-pill week-unsure">不確定</span>
      <span class="week-pill week-absent">未上線</span>
      <span class="week-legend-tip">（點擊成員欄位可切換狀態）</span>
      </div>

    </div>

    <!-- 右側 -->
    <div class="right-sticky-wrap">
    <div class="right-actions-bar">
    <button class="float-btn"  type="button" onclick="openGuildDrawer()">幫會職位</button>
    <!--<button class="float-btn danger" type="button" onclick="requestSave()">儲存</button>-->
    </div>

      <div class="panel" id="subs">
        <h3>替補名單</h3>
        <p style="font-size:0.7rem;margin-top:0;">可拖進本週；拖進已有成員欄位會交換。</p>
        <div id="subsList"></div>
        <div class="pagination" id="subsPager">
          <button onclick="subsPrev()">◀</button>
          <select id="subsPageSelect" onchange="subsJump(this.value)"></select>
          <button onclick="subsNext()">▶</button>
        </div>
        <button class="float-btn secondary" style="margin-top:.5rem;" onclick="addSub()">新增替補列</button>
      </div>

    </div>
  </div>

  <!-- 成員搜尋浮層 -->
  <div id="memberPicker">
    <input id="pickerSearch" placeholder="搜尋成員..." oninput="filterPickerList()" />
    <div class="picker-list" id="pickerList"></div>
  </div>

  <!-- 登入 modal -->
  <div id="loginModal">
    <div class="modal-card">
      <h3>請先登入</h3>
      <input id="loginUser" placeholder="帳號" />
      <input id="loginPass" placeholder="密碼" type="password" />
      <div style="display:flex;gap:.5rem;justify-content:flex-end;">
        <button class="float-btn secondary" onclick="closeLogin()">取消</button>
        <button class="float-btn" onclick="doLogin()">登入</button>
      </div>
      <p id="loginMsg" style="color:#b91c1c;font-size:.7rem;margin-top:.4rem;"></p>
    </div>
  </div>

  <!-- Loading 遮罩（放在 script 前面，讓 JS 找得到） -->
  <div id="loadingMask" class="loading-mask">
    <img src="loading.gif" alt="載入中">
  </div>

  <script>
    // ===== Debug 工具區 =====
const DEBUG_LOG = true;
let debugSeq = 0;
function dbg(tag, payload) {
  if (!DEBUG_LOG) return;
  debugSeq++;
  const time = new Date().toISOString().split("T")[1]; // 只要時間部分
  console.log(
    `[DBG #${debugSeq} ${time}] ${tag}`,
    JSON.parse(JSON.stringify(payload || {}))
  );
}

    const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
    const STORAGE_KEY = "guildCompareV12State";
    const LOGIN_STORAGE_KEY = "guildCompareLogin";
    const REMOTE_API = "https://script.google.com/macros/s/AKfycbyi96XOIYv7ff_gJO8IG-fGpGWfEE_ZQbKmFYMJQeuP9sbyf4gbrbnZIM-wO83cniYk/exec";
    const LOGIN_TTL = 60 * 60 * 1000;
    // 讓「最近修改框線」在編輯期間暫時隱藏
    let outlinesSuppressed = false;
    
    function suppressOutlinesOnEdit(){
    if (!outlinesSuppressed) {
    outlinesSuppressed = true;
    clearAllOutlines(); // 立刻把現有框線清掉
      }
    }
    
    let currentUser = null;
    let lastLoginTime = 0;

    const OUTLINE_CLASS = { dabai: "outline-dabai", baoan: "outline-baoan", stitch: "outline-stitch", unknown: "outline-dabai" };

    let lastKnownUpdatedAt = null;

    const teams = ["進攻","拆塔","機動","防守"];
    const roleColors = {
      "九靈": "#d8b4fe","鐵衣": "#fdba74","素問": "#f9a8d4","龍吟": "#92d46d","神相": "#3b82f6","碎夢": "#7dd3fc","血河": "#f43f5e"
    };

    let allMembers = [
      {id:1, name: "四季春曉川", job: "九靈", skill: "左鈎天浩意"},
      {id:2, name: "狐戀雪", job: "素問", skill: "太極圖"},
      {id:3, name: "翼歌", job: "龍吟", skill: "太極圖"},
      {id:4, name: "木子維", job: "鐵衣", skill: ""},
      {id:5, name: "給雀心裹", job: "神相", skill: ""},
      {id:6, name: "玖靨", job: "血河", skill: ""},
      {id:7, name: "阿妙", job: "素問", skill: ""},
      {id:8, name: "小葉青", job: "碎夢", skill: ""},
      {id:9, name: "破風", job: "血河", skill: "爆發"},
      {id:10, name: "青珂", job: "龍吟", skill: ""},
      {id:11, name: "煙雨", job: "九靈", skill: ""}
    ];

/* V16新增 幫會職位用的職業排序（你想要的職業順序） */
const guildJobOrder = ["九靈","鐵衣","素問","龍吟","神相","碎夢","血河"];
// 建立職業排序對照表
const guildJobOrderMap = {
  "九靈": 1,
  "鐵衣": 2,
  "素問": 3,
  "龍吟": 4,
  "神相": 5,
  "碎夢": 6,
  "血河": 7
};

/*V18.3顯示/隱藏讀取圖示*/
function showLoadingMask() {
  const el = document.getElementById("loadingMask");
  if (el) el.classList.add("show");
}
function hideLoadingMask() {
  const el = document.getElementById("loadingMask");
  if (el) el.classList.remove("show");
}


// V16幫眾＋號：開啟成員搜尋浮層
function openGuildAddPicker(btn) {
  window.guildAddMode = true;
  // 用按鈕本身當作定位元素（只拿來算位置）
  const target = btn || document.getElementById("guildBattleBox");
  if (!target) return;
  openMemberPicker(target);
}



// ★ 依目前選取狀態，決定交換按鈕是否可按
function updateGuildSwapButtonState() {
  const btn = document.getElementById("guildSwapBtn");
  if (!btn) return;
  const battleSelected = guildBattleBox
    ? guildBattleBox.querySelectorAll(".position-tag.guild-selected").length
    : 0;
  const pendingSelected = guildPendingBox
    ? guildPendingBox.querySelectorAll(".position-tag.guild-selected").length
    : 0;
  const total = battleSelected + pendingSelected;
  btn.disabled = total === 0;   // 沒有選任何紅／綠標籤就不能按
}


/* ★ 依職業重排某一個 guildBox（幫眾或學徒）
   紅／綠標籤一律排在最前面，再依職業順序與名字排序 */
function sortGuildBoxByJob(box) {
  if (!box) return;
  const tags = Array.from(box.querySelectorAll(".position-tag"));
  if (!tags.length) {
    box.classList.add("empty");
    return;
  }
  function rank(tag) {
    if (tag.dataset.placeholder === "1") return 0; // 空位最前
    if (tag.classList.contains("guild-missing-in-week")) return 1; // 紅
    if (tag.classList.contains("guild-from-week-only")) return 2; // 綠
    if (tag.classList.contains("guild-from-week-absent")) return 3; // 白（未上線）
    // 其他一般學徒
    return 4;
  }
  tags.sort((a, b) => {
    const ra = rank(a);
    const rb = rank(b);
    if (ra !== rb) return ra - rb;
    // 再依職業順序
    const jobA = guildJobOrderMap[a.dataset.job] || 99;
    const jobB = guildJobOrderMap[b.dataset.job] || 99;
    if (jobA !== jobB) return jobA - jobB;
    // 同職業按名字
    return (a.dataset.memberName || "").localeCompare(
      b.dataset.memberName || "",
      "zh-Hant"
    );
  });
  box.innerHTML = "";
  tags.forEach(t => box.appendChild(t));
  box.classList.remove("empty");
}



    let nextMemberId = 12;
    let activeRoleFilter = "";
    let lastSnapshot = null;
    let memberPage = 1;
    const pageSize = 8;
    let subCounter = 0;

    const thisWeekPanel = document.getElementById("thisWeek");
    // V18.3 自動替本週名單的名字欄位補上 data-side="this"
thisWeekPanel.querySelectorAll('input[data-role="name"]').forEach(inp => {
  inp.dataset.side = "this";
});

    const subsList = document.getElementById("subsList");
    const memberList = document.getElementById("memberList");
    const searchInput = document.getElementById("memberSearch");
    const roleTabs = document.getElementById("roleTabs");
    //V16新增以下兩個
    const guildBattleBox = document.getElementById("guildBattleBox");
    const guildPendingBox = document.getElementById("guildPendingBox");

    let weekStatusMap = {};   // V17.1全域：記錄每個名字目前的狀態
    let draggingPanelInput = null;
    let draggingPanelSide = null;
    let dragSuccess = false;
    let dragPreviewEl = null;
    let dragSourceSide = "";

    let pickerTargetInput = null;
    const memberPicker = document.getElementById("memberPicker");
    const pickerList = document.getElementById("pickerList");
    const pickerSearch = document.getElementById("pickerSearch");    


// V16 在指定的大框裡新增一個職位標籤（含：去重＋上限檢查＋空位管理）
function addGuildTag(box, member, options) {
  const isPendingBox = (box === guildPendingBox);
  const opts = options || {};
  const bypassRules = !!opts.bypassRules; // true = 不檢查（給還原舊資料用）
  const name = (member && member.name ? member.name : "").trim();
  if (!box || !name) return;
  // ── 一般操作時才檢查規則 ─────────────────
  if (!bypassRules) {
    // ✅ 只檢查「幫眾欄位」裡不能重複
    if (box === guildBattleBox) {
      const battleTags = guildBattleBox.querySelectorAll(".position-tag");
      for (const t of battleTags) {
        // 跳過空位標籤
        if (t.dataset.placeholder === "1") continue;
        if ((t.dataset.name || "").trim() === name) {
          alert(name + " 已經在幫眾名單裡了");
          return;
        }
      }

      // ❷ 可參戰職位（幫眾）最多 60 人：只算真正成員，不算空位
      const currentRealCount = Array.from(
        guildBattleBox.querySelectorAll(".position-tag")
      ).filter(t => t.dataset.placeholder !== "1").length;

      if (currentRealCount >= 60) {
        alert("可參戰職位（幫眾）最多只能放 60 人");
        return;
      }
    }
    // ✅ 學徒欄位：不做「不可重複」檢查，讓你自由放
  }
  // ── 建立標籤 UI ─────────────────────────
  box.classList.remove("empty");
  const tag = document.createElement("div");
  tag.className = "position-tag";
  tag.dataset.name = name;
  tag.dataset.job = member.job || getJobByName(name) || "";
  const job = tag.dataset.job;
  if (job && roleColors[job]) {
    const dark = darkenHex(roleColors[job], 0.25);
    tag.style.borderLeft = "4px solid " + dark;
    tag.style.color = dark;
  }
  const nameSpan = document.createElement("span");
  nameSpan.textContent = name;
  tag.appendChild(nameSpan);

 
  const btn = document.createElement("button");
  btn.type = "button";
  btn.className = "position-tag-remove";
  btn.textContent = "×";

   if (!isPendingBox) {
  btn.onclick = function (e) {
    e.stopPropagation();
    // 取成員名字（先看有沒有寫在 data-member-name，沒有就用文字再把「×」去掉）
    const rawText = (tag.dataset.memberName || tag.textContent || "").trim();
    const name = rawText.replace("×", "").trim() || "這位成員";
    // ✅ 新增確認視窗
    const ok = confirm(`確定要從「幫眾」名單中移除「${name}」嗎？`);
    if (!ok) return;   // 使用者按「取消」就什麼都不做
    // 原本的刪除流程維持不變
    tag.remove();
    if (!box.querySelector(".position-tag")) {
      box.classList.add("empty");
    }
    // ★ 刪成員後要重新補空位（只對幫眾欄位）
    if (box === guildBattleBox) {
      maintainGuildBattlePlaceholders();
      updateGuildBattleAndWeekComparison();
    }
    saveState();
  };
  tag.appendChild(btn);
}


  box.appendChild(tag);
  // ★ 新增成員後也要維持 60 格
  if (box === guildBattleBox) {
    maintainGuildBattlePlaceholders();
    updateGuildBattleAndWeekComparison();
  }



  // ★ 紅／綠標籤可點選成「選中狀態」
  tag.addEventListener("click", function (e) {
    // 點到叉叉不算選取
    if (e.target.closest(".position-tag-remove")) return;
    // 只有紅／綠標籤才能被選取
    if (
      !tag.classList.contains("guild-missing-in-week") &&
      !tag.classList.contains("guild-from-week-only") &&
      !tag.classList.contains("guild-from-week-absent") &&
      !tag.classList.contains("guild-from-week-unsure")
    ) {
      return;
    }
    tag.classList.toggle("guild-selected");
    updateGuildSwapButtonState();
  });

  // ★ 找到「最後一個同職業標籤」，讓同職業排在一起
  let insertBefore = null;
  if (job) {
    const siblings = Array.from(box.querySelectorAll(".position-tag"));
    let lastSameJob = null;
    siblings.forEach(t => {
      if ((t.dataset.job || "") === job) {
        lastSameJob = t;
      }
    });
    if (lastSameJob) {
      insertBefore = lastSameJob.nextSibling;
    }
  }

  if (insertBefore) {
    box.insertBefore(tag, insertBefore);
  } else {
    box.appendChild(tag);
  }
}

// V16★ 維持「可參戰幫眾」固定 60 格：不足用空位紅標籤補齊
function maintainGuildBattlePlaceholders() {
  if (!guildBattleBox) return;
  const MAX = 60;
  const allTags = Array.from(
    guildBattleBox.querySelectorAll(".position-tag")
  );
  // 真實幫眾（有名字的）
  const realTags = allTags.filter(t => t.dataset.placeholder !== "1");
  // 空位標籤
  let placeholders = allTags.filter(t => t.dataset.placeholder === "1");
  const realCount = realTags.length;
  let needPlaceholders = Math.max(0, MAX - realCount);
  // 多餘的空位標籤移除
  if (placeholders.length > needPlaceholders) {
    const extra = placeholders.slice(needPlaceholders);
    extra.forEach(t => t.remove());
    placeholders = placeholders.slice(0, needPlaceholders);
  }
  // 不足的空位標籤補齊
  if (placeholders.length < needPlaceholders) {
    const toAdd = needPlaceholders - placeholders.length;
    for (let i = 0; i < toAdd; i++) {
      const tag = document.createElement("div");
      // ★ 空位 = 紅標籤（跟缺席幫眾同一種）
      tag.className = "position-tag guild-missing-in-week";
      tag.dataset.placeholder = "1";     // 標記這顆是「空位」

      const span = document.createElement("span");
      span.textContent = "尚有空閒位置";     // 想改「空閒位置」也可以
      tag.appendChild(span);

      // ★ 空位也可以被選取，參與交換
      tag.addEventListener("click", function (e) {
        // 雖然空位沒有叉叉，這行是防呆
        if (e.target.closest(".position-tag-remove")) return;
        // 這顆本身就是紅標籤 → 切換選取狀態
        tag.classList.toggle("guild-selected");
        updateGuildSwapButtonState();
      });
      guildBattleBox.appendChild(tag);
      placeholders.push(tag);
    }
  }
  // ★ 讓「空位紅標籤」排在最前面，再排真實幫眾
  const ordered = [...placeholders, ...realTags];
  ordered.forEach(tag => guildBattleBox.appendChild(tag));

  if (ordered.length === 0) {
    guildBattleBox.classList.add("empty");
  } else {
    guildBattleBox.classList.remove("empty");
  }
/*V16.1 更新幫眾數字*/
    const label = document.getElementById("guildCountLabel");
  if (label) {
    label.textContent = realCount + "/60";
  }

}

// V18.2 提示氣泡用，取得成員原本所在的「團名 + 第幾小隊」
function getGroupAndSquad(nameInput) {
  if (!nameInput) return "";
  // 從 HTML 結構往上找 team-block（含團名）
  const teamBlock = nameInput.closest(".team-block");
  const squad = nameInput.closest(".squad");
  let groupText = "";
  let squadText = "";
  // 團名 (例：進攻 / 拆塔 / 機動 / 防守)
  if (teamBlock) {
    groupText = teamBlock.dataset.team || "";
  }
  // 第幾小隊 (例：第1小隊、第2小隊)
  if (squad) {
    if (squad.dataset.squad) {
      squadText = `第${squad.dataset.squad}小隊`;
    }
  }
  // 合併輸出
  if (groupText && squadText) return `${groupText} ${squadText}`;
  if (groupText) return groupText;
  if (squadText) return squadText;
  return "";
}



// V16 比對：幫眾 vs 本週名單
function updateGuildBattleAndWeekComparison() {
  if (!guildBattleBox || !guildPendingBox) return;
  // 1. 收集「本週名單」所有成員名稱＋狀態
  const weekNames = new Set();
  weekStatusMap = {};   // ← V17.1把 const 拿掉，改成重新把全域物件清空  // name -> 狀態（absent / late / unsure / present）
  thisWeekPanel.querySelectorAll("input[data-role='name']").forEach(inp => {
    const n = (inp.value || "").trim();
    if (!n) return;
    weekNames.add(n);
    const st = inp.dataset.status || "present";
    const prev = weekStatusMap[n];
    if (!prev) {
      weekStatusMap[n] = st;
    } else {
      // 同名多格時，用「優先級」最高的那一個（未上線 > 不確定 > 會晚到 > 已出席）
      const curP = MEMBER_STATUS_PRIORITY[st] || 0;
      const prevP = MEMBER_STATUS_PRIORITY[prev] || 0;
      if (curP > prevP) weekStatusMap[n] = st;
    }
  });
  // 2. 收集「幫眾」目前有哪些人
  maintainGuildBattlePlaceholders();   // 先確保幫眾空位正確
  const battleTags = Array.from(
    guildBattleBox.querySelectorAll(".position-tag")
  ).filter(tag => tag.dataset.placeholder !== "1"); // ★ 排除空位
  const pendingTags = Array.from(
    guildPendingBox.querySelectorAll(".position-tag")
  );

  const battleNames = new Set();
  battleTags.forEach(tag => {
    const n = (tag.dataset.name || "").trim();
    if (n) battleNames.add(n);
  });
  const pendingBox = guildPendingBox;
  // 2-1. 幫眾裡「沒出現在本週名單」的 → 紅色標籤
  battleTags.forEach(tag => {
    const n = (tag.dataset.name || "").trim();
    if (n && !weekNames.has(n)) {
      tag.classList.add("guild-missing-in-week");
    } else {
      tag.classList.remove("guild-missing-in-week");
    }
  });
  // 3. 先清掉之前【自動產生】的學徒標籤（避免越疊越多）
  pendingBox
    .querySelectorAll(".position-tag[data-auto='1']")
    .forEach(tag => tag.remove());
  // 重新讀一次學徒欄位現有的人（只算手動放的）
  const pendingNames = new Set();
  pendingBox.querySelectorAll(".position-tag").forEach(tag => {
    const n = (tag.dataset.name || "").trim();
    if (n) pendingNames.add(n);
  });
    // V17修改 4. 本週名單裡「沒有出現在幫眾」的 → 學徒欄位的標籤
  weekNames.forEach(name => {
    if (battleNames.has(name)) return;   // 已經是幫眾
    if (pendingNames.has(name)) return;  // 學徒原本就有人，不重複
    const job = getJobByName(name) || "";
    const status = weekStatusMap[name] || "present";
    addGuildTag(
      pendingBox,
      { name, job },
      { bypassRules: true }
    );
    const tag = Array.from(
      pendingBox.querySelectorAll(".position-tag")
    ).find(t => (t.dataset.name || "").trim() === name && !t.dataset.auto);
    if (tag) {
      tag.dataset.auto = "1";
      tag.dataset.weekStatus = status;
      tag.classList.remove("guild-missing-in-week");
      tag.classList.remove("guild-selected");
      if (status === "absent") { //v17新增
  tag.classList.add("guild-from-week-absent");
  tag.classList.remove("guild-from-week-only");
  tag.classList.remove("guild-from-week-late");
  tag.classList.remove("guild-from-week-unsure");
} else if (status === "late") {
  tag.classList.add("guild-from-week-late");
  tag.classList.remove("guild-from-week-absent");
  tag.classList.remove("guild-from-week-only");
  tag.classList.remove("guild-from-week-unsure");
} else if (status === "unsure") {
  tag.classList.add("guild-from-week-unsure");
  tag.classList.remove("guild-from-week-absent");
  tag.classList.remove("guild-from-week-only");
  tag.classList.remove("guild-from-week-late");
} else {
  /* present（已出席）→ 綠標籤 */
  tag.classList.add("guild-from-week-only");
  tag.classList.remove("guild-from-week-absent");
  tag.classList.remove("guild-from-week-late");
  tag.classList.remove("guild-from-week-unsure");
}

      applyWeekStatusIconToTag(tag, status);
    }
  });
  // 5. 排順序（同職業擺一起）
  sortGuildBoxByJob(guildBattleBox);
  sortGuildBoxByJob(guildPendingBox);
  // 6. 更新交換按鈕是否可按
  updateGuildSwapButtonState();
}

/*V16.1顯示訊息*/
let guildNoteTimer = null;
function showGuildSwapMessage(msg, color) {
  const note = document.querySelector(".guild-pos-note");
  if (!note) return;
  note.textContent = msg;
  note.style.color = color || "#2563eb"; // 預設藍色
  if (guildNoteTimer) clearTimeout(guildNoteTimer);
  guildNoteTimer = setTimeout(() => {
    note.textContent = "比對尚未更換職位的成員。";
    note.style.color = "#64748b";
  }, 2500);
}


 // ★ 交換選中的紅／綠標籤：幫眾 ↔ 學徒
function swapSelectedGuildMembers() {
  if (!guildBattleBox || !guildPendingBox) return;

  const redSelected = Array.from(
    guildBattleBox.querySelectorAll(
      ".position-tag.guild-missing-in-week.guild-selected"
    )
  );
    const greenSelected = Array.from(
    guildPendingBox.querySelectorAll(
      ".position-tag.guild-from-week-only.guild-selected, " +
      ".position-tag.guild-from-week-absent.guild-selected, " +
      ".position-tag.guild-from-week-unsure.guild-selected"
    )
  );

  const redCount = redSelected.length;
  const greenCount = greenSelected.length;
  if (redCount === 0 && greenCount === 0) {
    return;   // 理論上此時按鈕已 disabled
  }
  if (redCount !== greenCount) {
    // 數量不一樣 → 顯示是哪邊少選了幾個
    let msg = "無法交換：";
    if (redCount < greenCount) {
      msg += "幫眾少選了 " + (greenCount - redCount) + " 個。";
    } else {
      msg += "學徒少選了 " + (redCount - greenCount) + " 個。";
    }
    alert(msg);
    return;
  }
  // 先確認交換後幫眾不會超過 60 人
  const currentBattleCount = guildBattleBox.querySelectorAll(".position-tag").length;
  const afterBattle = currentBattleCount - redCount + greenCount;
  if (afterBattle > 60) {
    alert("可參戰職位（幫眾）最多 60 人，交換後會超過 60 人，請少選幾個。");
    return;
  }
  // 先記錄要從學徒升上來的人
  const promoteList = greenSelected.map(tag => {
    const name = (tag.dataset.name || "").trim();
    const job  = tag.dataset.job || getJobByName(name) || "";
    return { name, job };
  });
  // 把學徒中選中的綠標籤移除
  greenSelected.forEach(tag => {
    const box = tag.parentElement;
    tag.remove();
    if (box && !box.querySelector(".position-tag")) {
      box.classList.add("empty");
    }
  });
  // 把幫眾中選中的紅標籤移除（等於移出幫眾名單）
  redSelected.forEach(tag => {
    const box = tag.parentElement;
    tag.remove();
    if (box && !box.querySelector(".position-tag")) {
      box.classList.add("empty");
    }
  });
  // 把原本學徒的綠標籤，新增成幫眾（視為正式幫眾）
  promoteList.forEach(m => {
    addGuildTag(guildBattleBox, m, { bypassRules: true });
  });
  // 清掉所有選取狀態
  document
    .querySelectorAll(".position-tag.guild-selected")
    .forEach(t => t.classList.remove("guild-selected"));
   // 重新比對紅／綠、重排順序
  updateGuildBattleAndWeekComparison();
  // 先存到 localStorage
  saveState();
  // ★ 再呼叫遠端儲存（會自動檢查登入 & 打到 GAS）
  requestSave();
  // 更新交換按鈕可按狀態
  updateGuildSwapButtonState();
  // V16.1新增，靜默儲存到後台，成功後顯示訊息
requestSave({
  silent: true,
  onSuccess() {
    showGuildSwapMessage("交換完成，已同步生效", "#2563eb");
  }
});
}


    function sameJSON(a,b){return JSON.stringify(a)===JSON.stringify(b);}

    function teamColorByName(name){
      if(name==="拆塔") return "#7f1d1d";
      if(name==="機動") return "#4c1d95";
      if(name==="防守") return "#1e3a8a";
      return "#0f172a";
    }
    function hexToRgb(hex){const s=hex.replace('#','');const n=parseInt(s,16);return {r:(n>>16)&255,g:(n>>8)&255,b:n&255};}
    function rgbToHsl(r,g,b){r/=255; g/=255; b/=255; const max=Math.max(r,g,b),min=Math.min(r,g,b); let h,s,l=(max+min)/2; if(max===min){h=s=0;} else{const d=max-min; s=l>0.5?d/(2-max-min):d/(max+min); switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break;} h/=6;} return {h,s,l};}
    function hslToHex(h,s,l){function f(n){const k=(n+h*12)%12; const a=s*Math.min(l,1-l); const c=l-a*Math.max(-1, Math.min(k-3, Math.min(9-k,1))); return Math.round(255*c).toString(16).padStart(2,'0');} return "#"+f(0)+f(8)+f(4);}
    function darkenHex(hex, amt=0.25){ const {r,g,b} = hexToRgb(hex); const {h,s,l} = rgbToHsl(r,g,b); const nl = Math.max(0, l - amt); return hslToHex(h,s,nl); }
    /*V16.2新增*/
    function lightenHex(hex, amt = 0.25) {
    const { r, g, b } = hexToRgb(hex);
    const { h, s, l } = rgbToHsl(r, g, b);
    const nl = Math.min(1, l + amt);
    return hslToHex(h, s, nl);
    }


    /* 依據寬度調整小隊欄寬 */
    function adjustSquadWidths(block) {
      const squadsContainer = block.querySelector('.squads');
      if (!squadsContainer) return;
      const squads = squadsContainer.querySelectorAll('.squad');
      const count = squads.length || 1;
      const width = window.innerWidth;

      if (width <= 768) {
        if (count <= 4) squads.forEach(sq => { sq.style.flex = "0 0 calc(21.5% - 6px)"; });
        else { const pct = 100 / count; squads.forEach(sq => { sq.style.flex = "0 0 calc(" + (pct - 4.8) + "%)"; }); }
        return;
      }
      if (width <= 1024) {
        if (count <= 4) squads.forEach(sq => { sq.style.flex = "0 0 calc(22.5% - 6px)"; });
        else { const pct = 100 / count; squads.forEach(sq => { sq.style.flex = "0 0 calc(" + (pct - 3.6) + "%)"; }); }
        return;
      }
      if (count <= 4) squads.forEach(sq => { sq.style.flex = "0 0 calc(23.5% - 6px)"; });
      else { const pct = 100 / count; squads.forEach(sq => { sq.style.flex = "0 0 calc(" + (pct - 2.3) + "%)"; }); }
    }
    window.addEventListener("resize", () => {
      document.querySelectorAll(".team-block").forEach(adjustSquadWidths);
    });

    /*V17修改，在手動輸入時維持狀態合理*/
    function handlePanelInputChange(input){ 
  input.dataset.dirty = "1"; 
  clearHighlightOnEdit(input); 
  // ★ 本週名字格：如果有名字但沒有 status，就給預設「未上線」
  if (input.dataset.side === "this" && input.dataset.role === "name") {
    const hasName = (input.value || "").trim() !== "";
    if (!hasName) {
      resetCellStatus(input);
    } else if (!input.dataset.status) {
      resetCellStatus(input);  // 新輸入的人，預設當作未上線
    } else {
      setCellStatus(input, input.dataset.status);
    }
  }
  saveState(); 
  if (input.dataset.side === "this" && input.dataset.role === "name") {
    updateGuildBattleAndWeekComparison();
  }
}


    function markDirty(el){ if (el) el.dataset.dirty = "1"; }


// ★ V17.1本週名單用的出席狀態
// absent = 未上線, present = 確認參戰, unsure = 不確定
const MEMBER_STATUS_ORDER = ["present", "unsure", "absent"]; // 點一下往下一個狀態
const MEMBER_STATUS_PRIORITY = {
  absent: 3,
  unsure: 2,
  present: 1,
};
const WEEK_STATUS_LABELS = {
  present: "確認參戰", // 已進組、或確定會晚到但會來
  unsure: "不確定",   // 狀況不明、掛機、說會來但時間到了還沒進組
  absent: "未上線",   // 根本沒上線
};


// V17.2 給本週欄位設定狀態（會影響視覺）
function setCellStatus(input, status) {
  if (!input) return;
  const nameRow = input.closest(".member-row");
  if (!nameRow) return;
  const skillRow = nameRow.nextElementSibling;
  const pairRows = [nameRow, skillRow].filter(Boolean);
  const oldStatus = input.dataset.status || "absent";
  // 先把舊狀態 class 拿掉
  pairRows.forEach(row => {
    row.classList.remove("status-absent", "status-late", "status-unsure", "status-present");
  });
  // 記錄新狀態
  input.dataset.status = status;
  // 標記新狀態
  const cls = "status-" + status;
  // ⭐V18.1修改 只在「名稱那一列」加上狀態 class
  nameRow.classList.add(cls);
  // 清掉舊 inline style（但保留 border-left）
  pairRows.forEach(row => {
    row.querySelectorAll("input").forEach(el => {
      el.style.background = "";
      el.style.borderColor = "";
      el.style.color = "";
    });
  });
  // ★ 調整職業條邏輯
  if (input.dataset.side === "this" && input.dataset.role === "name") {
    const memberName = (input.value || "").trim();
    const job = input.dataset.job || getJobByName(memberName) || "";

      //V17.2 ★ 調整職業條邏輯：所有狀態都用職業色
  if (input.dataset.side === "this" && input.dataset.role === "name") {
    const memberName = (input.value || "").trim();
    const job = input.dataset.job || getJobByName(memberName) || "";

    if (job && roleColors[job]) {
      const dark = darkenHex(roleColors[job], 0.25);
      // 不論 present / late / unsure / absent，都用職業色條
      input.style.borderLeft = "6px solid " + dark;
    } else {
      // 沒職業資料就清空
      input.style.borderLeft = "";
    }
  }
  }
  // 更新資料
  const name = (input.value || "").trim();
  if (name) {
    weekStatusMap[name] = status;
  } else if (weekStatusMap[name] === oldStatus) {
    delete weekStatusMap[name];
  }
  updateGuildBattleAndWeekComparison();
}




/*V17修改空格＝完全沒狀態，有名字＝未上線*/
function resetCellStatus(input) {
  if (!input) return;
  const hasName = (input.value || "").trim() !== "";
  if (!hasName) {
    // 空欄位：不套任何狀態／顏色
    clearCellStatus(input);
    return;
  }
  // 有名字但沒特別指定 → 預設為「未上線」
  setCellStatus(input, "absent");
}


/*V17新增清掉顏色*/
function clearCellStatus(input) {
  if (!input) return;
  delete input.dataset.status;
  const nameRow = input.closest(".member-row");
  if (!nameRow) return;
  const all = ["status-absent", "status-present", "status-late", "status-unsure"];
  nameRow.classList.remove(...all);
  const skillRow = nameRow.nextElementSibling;
  if (skillRow && skillRow.classList.contains("member-row")) {
    skillRow.classList.remove(...all);
  }
}

/*17.1修改*/
function cycleCellStatus(input) {
  if (!input) return;
  const current = input.dataset.status || "absent"; // 預設視為「未上線」
  const idx = MEMBER_STATUS_ORDER.indexOf(current);
  const next = MEMBER_STATUS_ORDER[(idx + 1) % MEMBER_STATUS_ORDER.length];
  setCellStatus(input, next);
  // 狀態會影響學徒自動產生 → 重新比對
  if (input.dataset.side === "this" && input.dataset.role === "name") {
    updateGuildBattleAndWeekComparison();
    saveState();
  }
}

/*V17修改*/
function createMemberInputs(side) {
  const isThisWeek = side === "this";
  let html = "";
  for (let i = 1; i <= 6; i++) {
    html += `
      <div class="member-row">
        <input
          data-role="name"
          data-side="${side}"
          draggable="true"
          ondragstart="dragFromPanel(event)"
          ondragover="allowDrop(event)"
          ondrop="dropMember(event)"
          oncontextmenu="return false"
          oninput="handlePanelInputChange(this)"
          onclick="onNameCellClick(event, this)"
          placeholder="成員${i}"
        >
      </div>
      <div class="member-row">
        <input
          data-role="skill"
          class="readonly-skill"
          placeholder=""
          readonly
        >
      </div>
    `;
  }
  return html;
}


    function createGroupTagSelect(selected="一團") {
      const opts = ["一團","二團","三團","四團"];
      return `
        <select class="team-tag-select" onchange="markDirty(this); saveState()">
          ${opts.map(o => `<option value="${o}" ${o===selected?'selected':''}>${o}</option>`).join("")}
        </select>
      `;
    }

    function createSquad(idx, side, teamName){
      const sq = document.createElement("div");
      sq.className = "squad";
      sq.dataset.squad = idx;
      sq.innerHTML = `
        <div class="squad-title">第${idx}小隊</div>
        ${side==="this" ? `<button class="squad-del-btn" onclick="deleteThisSquad(this)">×</button>` : ""}
        ${createMemberInputs(side)}
      `;
      return sq;
    }

function createTeamBlock(side, teamName, tag = "一團") {
  const block = document.createElement("div");
  block.className = "team-block";
  block.dataset.team = teamName;
  block.dataset.side = side;        // 現在實際只會是 "this"
  const headColor = teamColorByName(teamName);

  block.innerHTML = `
    <div class="team-head" style="background:${headColor}">
      <div class="team-head-left">
        <!-- 固定就是本週 -->
        <span class="th-title">本週－${teamName}</span>
        <!-- 一律用下拉選擇團別 -->
        ${createGroupTagSelect(tag)}
      </div>
      <div class="head-actions">
        <!-- 一律可新增小隊 -->
        <button class="head-add-btn" onclick="addSquadToTeamFromHead(this)">＋ 新增小隊</button>
      </div>
    </div>
    <div class="squads"></div>
  `;

  const sqs = block.querySelector(".squads");
  for (let s = 1; s <= 3; s++) {
    sqs.appendChild(createSquad(s, side, teamName));
  }
  block.dataset.lastSquadCount = "3";
  adjustSquadWidths(block);
  return block;
}

teams.forEach(t => {
  thisWeekPanel.appendChild(createTeamBlock("this", t));
  // V17★ 建好本週名單後，初始化狀態為「未上線」
  thisWeekPanel
  .querySelectorAll("input[data-role='name'][data-side='this']")
  .forEach(inp => resetCellStatus(inp));

});


// V17.4檢查單一 input 是否需要跑馬燈
function updateMarqueeForInput(input) {
  // 先暫時清掉，避免舊的 text-indent 影響測量
  input.classList.remove("marquee");
  // 使用 scrollWidth vs clientWidth 判斷是否有溢出
  const need = input.scrollWidth > input.clientWidth + 1;
  if (need) {
    input.classList.add("marquee");
  }
}
// 檢查本週名單所有欄位
function updateAllThisWeekMarquee() {
  document.querySelectorAll("#thisWeek .member-row input").forEach(updateMarqueeForInput);
}
// 一開始載入頁面時檢查一次
window.addEventListener("load", updateAllThisWeekMarquee);
// 視窗大小改變時也檢查一次
window.addEventListener("resize", updateAllThisWeekMarquee);
// 當使用者輸入內容時，立刻檢查該欄位
document.addEventListener("input", (e) => {
  if (e.target.matches("#thisWeek .member-row input")) {
    updateMarqueeForInput(e.target);
  }
});

    function setupPanelCarousel(panelId) {
      const panel = document.getElementById(panelId);
      if (!panel) return;

      const blocks = Array.from(panel.querySelectorAll(".team-block"));
      if (!blocks.length) return;

      const wrap = document.createElement("div");
      wrap.className = "teams-wrap";
      blocks.forEach(b => wrap.appendChild(b));
      panel.appendChild(wrap);

      const dots = document.createElement("div");
      dots.className = "team-dots";
      panel.appendChild(dots);

      /*V16.2滑動動畫*/
      let current = 0;
  function show(index) {
  if (index < 0 || index >= blocks.length) return;
  // ★ 先決定是往左還是往右
  let dir = null;
  if (index > current) dir = "right";
  else if (index < current) dir = "left";
  current = index;
  blocks.forEach((b, i) => {
    const willActive = (i === index);
    b.classList.toggle("active", willActive);
    // 只有要顯示的那一團才套動畫
    if (willActive) {
      b.classList.remove("slide-from-left", "slide-from-right");
      // 強制 reflow，讓動畫可以重播
      void b.offsetWidth;
      if (dir === "right") {
        b.classList.add("slide-from-right");
      } else if (dir === "left") {
        b.classList.add("slide-from-left");
      }
    }
  });
  const allDots = dots.querySelectorAll(".team-dot");
  allDots.forEach((d, i) => { d.classList.toggle("active", i === index); });
  // 保留你原本的 thisWeekCarousel 邏輯
  if (panelId === "thisWeek") {
    if (!window.thisWeekCarousel) window.thisWeekCarousel = {};
    window.thisWeekCarousel._show = show;
    window.thisWeekCarousel.index = index;
    window.thisWeekCarousel.count = blocks.length;
    // ★ V18.2切換團隊後，重算一次本週名單的跑馬燈
    setTimeout(updateAllThisWeekMarquee, 0);
  }
}



  /*V16.2修改圓點顏色*/
  blocks.forEach((b, idx) => {
  const dot = document.createElement("button");
  dot.type = "button";
  dot.className = "team-dot" + (idx === 0 ? " active" : "");
  // ★ 你可以自由改這裡的顏色（圓點用）
const teamDotColors = {
  "進攻": "#27374D", // 黑
  "拆塔": "#D84040", // 紅
  "機動": "#9B5DE0", // 紫
  "防守": "#40679E"  // 藍
};
  // ★ 用團隊名稱決定圓點底色
  const teamName = b.dataset.team || "";
  // 先看有沒有你自己指定的圓點顏色
  const customDotColor = teamDotColors[teamName];
  if (customDotColor) {
  dot.style.background = customDotColor;
  } else {
  // 沒設定時才退回原本邏輯
  const baseColor = teamColorByName(teamName);
  if (baseColor) {
    dot.style.background = lightenHex(baseColor, 0.35);
  } else {
    dot.style.background = "#e2e8f0";
  }
}

  dot.onclick = () => show(idx);
  dots.appendChild(dot);
});


      let startX = 0, startY = 0, locked = false, isHorizontal = false;
      wrap.addEventListener("touchstart", function (e) {
        if (!e.touches || e.touches.length === 0) return;
        startX = e.touches[0].clientX; startY = e.touches[0].clientY; locked = false; isHorizontal = false;
      }, { passive: true });

      wrap.addEventListener("touchmove", function (e) {
        const t = e.touches && e.touches[0]; if (!t) return;
        const diffX = t.clientX - startX; const diffY = t.clientY - startY;
        if (!locked) { if (Math.abs(diffX) > 8 || Math.abs(diffY) > 8) { locked = true; isHorizontal = Math.abs(diffX) > Math.abs(diffY); } }
        if (locked && isHorizontal) e.preventDefault();
      }, { passive: false });

      wrap.addEventListener("touchend", function (e) {
        if (!locked || !isHorizontal) return;
        const endTouch = e.changedTouches && e.changedTouches[0]; if (!endTouch) return;
        const diffX = endTouch.clientX - startX; if (Math.abs(diffX) < 40) return;
        if (diffX < 0) { if (current < blocks.length - 1) show(current + 1); }
        else { if (current > 0) show(current - 1); }
      });

      /*V16.2新增團隊切換控制器*/
      if (panelId === "thisWeek") {
  window.thisWeekCarousel = window.thisWeekCarousel || {};
  window.thisWeekCarousel._show = show;
  window.thisWeekCarousel.index = 0;
  window.thisWeekCarousel.count = blocks.length;
  window.thisWeekCarousel.next = function () {
    if (this.index < this.count - 1) {
      this._show(this.index + 1);
    }
  };
  window.thisWeekCarousel.prev = function () {
    if (this.index > 0) {
      this._show(this.index - 1);
    }
  };
}
  show(0);
      
    }
    setupPanelCarousel("thisWeek");

  // ★★ V16.2 滑鼠滾輪切換團隊（桌機用）★★
  (function enableWheelSwitchOnThisWeek() {
  if (!thisWeekPanel) return;
  let lastSwitch = 0;
  const COOL_DOWN = 400; // 兩次切換間隔（毫秒），避免一滾跳很多團
  thisWeekPanel.addEventListener("wheel", function (e) {
    if (!window.thisWeekCarousel) return;
    // 判斷主要是上下還是左右的滾動
    const delta = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? e.deltaX : e.deltaY;
    if (Math.abs(delta) < 10) return; // 太小的變化就忽略
    const now = Date.now();
    if (now - lastSwitch < COOL_DOWN) return; // 節流，避免一次滾好幾團
    // 在本週名單上滾輪時，就不要讓整頁一起滾動
    e.preventDefault();
    if (delta > 0) {
      // 往下或往右滾 → 下一團
      window.thisWeekCarousel.next && window.thisWeekCarousel.next();
    } else {
      // 往上或往左滾 → 上一團
      window.thisWeekCarousel.prev && window.thisWeekCarousel.prev();
    }
    lastSwitch = now;
  }, { passive: false });
})();



/*V117.2修改新增監聽，只要在拖曳時滑進團隊區域邊緣，就呼叫切換頁面*/
    let lastTeamAutoSwitchTime = 0;
  function handleThisWeekDragOver(e) {
  // ★ 桌機版：如果拖曳來源不是「本週名單」，就不要自動切換團
  if (window.innerWidth > 1300 && dragSourceSide !== "this") {
    return;
  }
  if (!window.thisWeekCarousel || !window.thisWeekCarousel._show) return;
  const panel = thisWeekPanel;
  if (!panel) return;
  // 讓這個區域可以當 drop 目標
  e.preventDefault();
  const rect = panel.getBoundingClientRect();
  const x = e.clientX;
  const edge = 48; // 距離邊緣 48px 內就算靠邊
  let dir = null;
  if (x - rect.left < edge) {
    dir = "prev";
  } else if (rect.right - x < edge) {
    dir = "next";
  }
  if (!dir) return;
  const now = Date.now();
  // 節流：0.6 秒內最多切一次，避免狂跳
  if (now - lastTeamAutoSwitchTime < 600) return;
  if (dir === "prev") {
    window.thisWeekCarousel.prev();
  } else {
    window.thisWeekCarousel.next();
  }
  lastTeamAutoSwitchTime = now;
}
// ★ 不再判斷寬度，永遠綁定，判斷交給 handler 本身
thisWeekPanel.addEventListener("dragover", handleThisWeekDragOver);




    function renumberSquads(block){
      const sqs = block.querySelectorAll(".squad");
      sqs.forEach((sq,idx)=>{ sq.dataset.squad = idx+1; const title = sq.querySelector(".squad-title"); if(title) title.textContent = `第${idx+1}小隊`; });
    }

    function addSquadToTeamFromHead(btn){
      const block = btn.closest(".team-block");
      const sqs = block.querySelector(".squads");
      const side = block.dataset.side;
      const teamName = block.dataset.team;
      const count = sqs.children.length;
      const newSq = createSquad(count + 1, side, teamName);
      newSq.dataset.newlyAdded = "1";
      sqs.appendChild(newSq);
      adjustSquadWidths(block);
      markDirty(block);
      saveState();
    }

    function deleteThisSquad(btn){
      const squad = btn.closest(".squad");
      const block = btn.closest(".team-block");
      const parent = squad.parentElement;
      if(confirm("確定要刪除這個小隊嗎？")){
        parent.removeChild(squad);
        renumberSquads(block);
        adjustSquadWidths(block);
        markDirty(block);
        block.dataset.lastSquadCount = String(parent.children.length);
         // ★V18.2 新增：刪除小隊後，重新比對幫眾與本週名單
        updateGuildBattleAndWeekComparison();
        saveState();
      }
    }

function clearPanelCell(e) {
  e.preventDefault();
  const input = e.target;
  if (input.dataset.role === "name") {
    clearInputAndSkill(input);
    markDirty(input);
    saveState();
    // ★ 若是本週名單 → 重新比對
    if (input.dataset.side === "this") {
      updateGuildBattleAndWeekComparison();
    }
  }
}

// V18.2 本週名單移動成員用的小提示泡泡
let weekToastTimer = null;
function showWeekToast(message, anchorInput) {
  if (!anchorInput) return;
  // 建立或取得現有的 toast
  let toast = document.getElementById("weekToast");
  if (!toast) {
    toast = document.createElement("div");
    toast.id = "weekToast";
    toast.className = "week-toast";
    document.body.appendChild(toast);
  }
  toast.textContent = message;
  // 取得 input 的位置
  const rect = anchorInput.getBoundingClientRect();
  // 定位：在 input 正上方水平置中
  toast.style.top = (window.scrollY + rect.top - 15) + "px";
  toast.style.left = (window.scrollX + rect.left + rect.width / 2) + "px";
  toast.classList.add("show");
  if (weekToastTimer) clearTimeout(weekToastTimer);
  weekToastTimer = setTimeout(() => {
    toast.classList.remove("show");
  }, 2200);  //顯示2.2秒
}

/*V18.3替補名單顯示「已排入本週名單」*/
    function updateSubStatusByThisWeek() {
  if (!subsList) return;
  const weekNames = getThisWeekNameSet();
  subsList.querySelectorAll(".substitute-row").forEach(row => {
    const nameInput = row.querySelector(".sub-name");
    const statusSpan = row.querySelector(".sub-status");
    if (!nameInput || !statusSpan) return;
    const name = (nameInput.value || "").trim();
    if (name && weekNames.has(name)) {
      statusSpan.textContent = "已排入本週名單";
      statusSpan.style.color = "#dc2626";  // 紅字
    } else {
      statusSpan.textContent = "";
      statusSpan.style.color = "";
    }
  });
}

    function clearInputAndSkill(input){
      input.value = "";
      input.style.borderLeft = "";
      input.style.color = "";
      input.dataset.job = "";
      resetCellStatus(input);   // V17新增★ 清空時同步把狀態改回未上線
      const skillRow = input.parentElement.nextElementSibling;
      if (skillRow && skillRow.querySelector("input[data-role='skill']")) {
        const skillInput = skillRow.querySelector("input[data-role='skill']");
        setSkillInputValue(skillInput, "");
      }
      input.classList.remove("highlight-new","highlight-missing");
    }

    function clearHighlightOnEdit(input){ input.classList.remove("highlight-new","highlight-missing"); }

    let subsPage = 1;
    const subsPerPage = 3;

    function createSubRow(name = "", skill = "", markDirty = false) {
      const row = document.createElement("div");
      row.className = "substitute-row";
      row.draggable = true;
      row.dataset.subIndex = subCounter++;
      if (markDirty) row.dataset.dirty = "1";
      row.ondragstart = dragFromSub;
      row.innerHTML = `
  <input class="sub-name" placeholder="替補成員" value="${name}"
    onclick="maybeOpenMemberPicker(event, this)"
    ondragover="allowDrop(event)" ondrop="dropMember(event)"
    onblur="applyColorByName(this); markDirty(this); saveState(); updateSubStatusByThisWeek();">
  <input class="sub-skill" placeholder="技能" value="${skill}" oninput="markDirty(this); saveState()">
  <button class="del-btn" onclick="deleteSub(this)">刪</button>
  <span class="sub-status"></span>
`;  /*V15.1新增擋點擊*/

      // ⭐ 取得替補名字欄
  const nameInput = row.querySelector(".sub-name");
  // 套顏色（原本就有的邏輯）
  applyColorByName(nameInput);
  // ⭐ 新增：一建立就先算一次字體大小
  /*fitNameFont(nameInput);*/
      subsList.appendChild(row);
    } 

  /*V15.1新增 替補也鎖點擊*/
function onSubNameClick(e, input) {
  const val = (input.value || "").trim();
  // ✅ 欄位裡已經有名字：不讓它進入編輯，只能當拖曳的那一列
  if (val) {
    e.preventDefault();
    e.stopPropagation();
    input.blur();  // 把游標收掉，避免跳出鍵盤
    return;
  }
  // ✅ 空白欄位：保留原本行為，可以點進去打字或當 drop 目標
}

    
    function refreshSubsView() {
      const rows = Array.from(subsList.children);
      const totalPages = Math.max(1, Math.ceil(rows.length / subsPerPage));
      if (subsPage > totalPages) subsPage = totalPages;
      rows.forEach((row, idx) => {
        const pageOfRow = Math.floor(idx / subsPerPage) + 1;
        row.style.display = (pageOfRow === subsPage) ? "grid" : "none";
      });
      const sel = document.getElementById("subsPageSelect");
      if (sel) {
        sel.innerHTML = "";
        for (let p = 1; p <= totalPages; p++) {
          const opt = document.createElement("option");
          opt.value = p;
          opt.textContent = "第 " + p + " 頁";
          if (p === subsPage) opt.selected = true;
          sel.appendChild(opt);
        }
      }
    }
    function subsPrev() { if (subsPage > 1) { subsPage--; refreshSubsView(); } }
    function subsNext() {
      const rows = Array.from(subsList.children);
      const totalPages = Math.max(1, Math.ceil(rows.length / subsPerPage));
      if (subsPage < totalPages) { subsPage++; refreshSubsView(); }
    }
    function subsJump(p) { subsPage = parseInt(p, 10) || 1; refreshSubsView(); }

    function addSub() { createSubRow("", "", true); saveState(); refreshSubsView(); }
    function deleteSub(btn) { subsList.removeChild(btn.parentElement); saveState(); refreshSubsView(); }

    function renderRoleTabs(){
      roleTabs.innerHTML = "";
      const allTab = document.createElement("div");
      allTab.className = "role-tab" + (activeRoleFilter==="" ? " active" : "");
      allTab.textContent = "全部";
      allTab.style.background = "#e2e8f0";
      allTab.onclick = ()=>{activeRoleFilter=""; memberPage=1; renderMemberList();};
      roleTabs.appendChild(allTab);
      Object.keys(roleColors).forEach(r=>{
        const tab = document.createElement("div");
        tab.className = "role-tab" + (activeRoleFilter===r ? " active" : "");
        tab.textContent = r;
        tab.style.background = roleColors[r];
        tab.onclick = ()=>{activeRoleFilter=r; memberPage=1; renderMemberList();};
        roleTabs.appendChild(tab);
      });
    }

    function getFilteredMembers(){
      const keyword = searchInput.value.trim();
      return allMembers.filter(m=>{
        const matchRole = !activeRoleFilter || m.job===activeRoleFilter;
        const matchText = !keyword || m.name.includes(keyword) || (m.skill && m.skill.includes(keyword));
        return matchRole && matchText;
      });
    }

    function renderMemberList(){
      const filtered = getFilteredMembers();
      const totalPages = Math.max(1, Math.ceil(filtered.length / pageSize));
      if(memberPage>totalPages) memberPage = totalPages;
      const start = (memberPage-1)*pageSize;
      const pageItems = filtered.slice(start, start+pageSize);

      memberList.innerHTML = "";
      pageItems.forEach(m=>{
        const item = document.createElement("div");
        item.className = "member-item";
        item.draggable = true;
        item.ondragstart = e => dragFromMemberList(e, m);
        const darkColor = m.job && roleColors[m.job] ? darkenHex(roleColors[m.job],0.25) : "#e2e8f0";
        item.style.borderLeft = "4px solid " + darkColor;
        item.innerHTML = `
          <div class="member-left" data-id="${m.id}">
            <div class="member-name" style="color:${darkColor}">${m.name}</div>
            <div class="member-skill">${m.skill || ""}</div>
          </div>
          <div class="member-actions" id="member-actions-${m.id}">
            <button onclick="startInlineEdit(${m.id})">編</button>
            <button onclick="deleteMember(${m.id})">刪</button>
          </div>
        `;
        memberList.appendChild(item);
      });

      const sel = document.getElementById("pageSelect");
      sel.innerHTML = "";
      for(let p=1;p<=totalPages;p++){
        const opt = document.createElement("option");
        opt.value = p;
        opt.textContent = "第 " + p + " 頁";
        if(p===memberPage) opt.selected = true;
        sel.appendChild(opt);
      }
    }
    function prevPage(){ if(memberPage>1){ memberPage--; renderMemberList(); } }
    function nextPage(){
      const totalPages = Math.max(1, Math.ceil(getFilteredMembers().length / pageSize));
      if(memberPage<totalPages){ memberPage++; renderMemberList(); }
    }
    function jumpPage(p){ memberPage = parseInt(p,10); renderMemberList(); }
    
    /*V16新增檢查人數*/
    function toggleAddMember() {
  const form = document.getElementById("addMemberForm");
  const limitMsg = document.getElementById("memberLimitMsg");
  if (allMembers.length >= 80) {
    // 滿員：不打開表單，只顯示提示文字
    if (form) form.style.display = "none";
    if (limitMsg) limitMsg.style.display = "block";
    return;
  }
  if (limitMsg) limitMsg.style.display = "none";
  form.style.display = form.style.display === "flex" ? "none" : "flex";
}


    /*V16更新檢查人數*/
    function addMember() {
  const limitMsg = document.getElementById("memberLimitMsg");
  // ★ 先檢查上限 80 人
  if (allMembers.length >= 80) {
    if (limitMsg) limitMsg.style.display = "block";
    // 不新增
    return;
  }
  const name = document.getElementById("newName").value.trim();
  const job = document.getElementById("newJob").value;
  const skill = document.getElementById("newSkill").value.trim();
  if (!name || !job) {
    alert("成員名稱與職業必填");
    return;
  }
  allMembers.push({ id: ++nextMemberId, name, job, skill });
  document.getElementById("newName").value = "";
  document.getElementById("newJob").value = "";
  document.getElementById("newSkill").value = "";
  renderMemberList();
  document.getElementById("addMemberForm").style.display = "none";
  if (limitMsg) limitMsg.style.display = "none";
  saveState();
}


    function startInlineEdit(id){
      const item = [...memberList.querySelectorAll(".member-left")].find(div=>parseInt(div.dataset.id,10)===id);
      if(!item) return;
      const m = allMembers.find(x=>x.id===id);
      const actionArea = document.getElementById(`member-actions-${id}`);
      if(actionArea) actionArea.style.display = "none";
      item.innerHTML = `
        <input class="edit-input" id="edit-name-${id}" value="${m.name}">
        <select class="edit-input" id="edit-job-${id}">
          <option value="九靈" ${m.job==="九靈"?"selected":""}>九靈</option>
          <option value="鐵衣" ${m.job==="鐵衣"?"selected":""}>鐵衣</option>
          <option value="素問" ${m.job==="素問"?"selected":""}>素問</option>
          <option value="龍吟" ${m.job==="龍吟"?"selected":""}>龍吟</option>
          <option value="神相" ${m.job==="神相"?"selected":""}>神相</option>
          <option value="碎夢" ${m.job==="碎夢"?"selected":""}>碎夢</option>
          <option value="血河" ${m.job==="血河"?"selected":""}>血河</option>
        </select>
        <input class="edit-input" id="edit-skill-${id}" value="${m.skill||""}">
        <div style="display:flex;gap:.3rem;">
          <button class="float-btn" style="margin-top:.3rem;font-size:.65rem;padding:.2rem .4rem;" onclick="saveInlineEdit(${id})">儲存</button>
          <button class="float-btn secondary" style="margin-top:.3rem;font-size:.65rem;padding:.2rem .4rem;" onclick="renderMemberList()">取消</button>
        </div>
      `;
    }

// V16✅ 當全部成員名單被編輯後，同步更新：本週＋替補＋幫會職位
function syncEditedMemberEverywhere(oldMember, newMember) {
  if (!oldMember) return;
  const oldName = (oldMember.name || "").trim();
  const newName = (newMember.name || "").trim();
  // 1. 本週名單
  thisWeekPanel.querySelectorAll("input[data-role='name']").forEach(inp => {
    if (inp.value.trim() === oldName) {
      inp.value = newName;
      applyJobColor(inp, newMember.job);

      const skillRow = inp.parentElement.nextElementSibling;
      if (skillRow && skillRow.querySelector("input[data-role='skill']")) {
        setSkillInputValue(
          skillRow.querySelector("input[data-role='skill']"),
          newMember.skill || ""
        );
      }
      inp.dataset.dirty = "1";
    }
  });
  // 2. 替補名單
  subsList.querySelectorAll(".substitute-row").forEach(row => {
    const nameInput  = row.querySelector(".sub-name");
    const skillInput = row.querySelector(".sub-skill");
    if (!nameInput) return;

    if (nameInput.value.trim() === oldName) {
      nameInput.value = newName;
      applyJobColor(nameInput, newMember.job);
      if (skillInput) skillInput.value = newMember.skill || "";
      nameInput.dataset.dirty = "1";
    }
  });
  // 3. 幫會職位（幫眾／學徒標籤）
  document.querySelectorAll(".guild-box .position-tag").forEach(tag => {
    const tagName = (tag.dataset.name || "").trim();
    if (tagName === oldName) {
      // 更新名字
      tag.dataset.name = newName;
      const span = tag.querySelector("span");
      if (span) span.textContent = newName;
      // 更新職業與顏色
      const job = newMember.job || getJobByName(newName) || "";
      tag.dataset.job = job;
      if (job && roleColors[job]) {
        const dark = darkenHex(roleColors[job], 0.25);
        tag.style.borderLeft = "4px solid " + dark;
        tag.style.color = dark;
      } else {
        tag.style.borderLeft = "1px solid #cbd5e1";
        tag.style.color = "#0f172a";
      }
    }
  });
  // ★ 改完職業後，幫眾／學徒各自重新排序一次
  sortGuildBoxByJob(guildBattleBox);
  sortGuildBoxByJob(guildPendingBox);
  // 同步存檔
  saveState();
}


    /*V14.8修改*/
    function saveInlineEdit(id){
  const name  = document.getElementById("edit-name-"+id).value.trim();
  const job   = document.getElementById("edit-job-"+id).value.trim();
  const skill = document.getElementById("edit-skill-"+id).value.trim();
  const idx   = allMembers.findIndex(x=>x.id===id);
  if (idx > -1) {
    const oldMember = { ...allMembers[idx] };           // ← 舊資料先留著
    const newMember = { id, name, job, skill };
    allMembers[idx] = newMember;                        // 更新 master
    renderMemberList();                                 // 重畫左側清單
    syncEditedMemberEverywhere(oldMember, newMember);   // ✅ 同步到本週＋替補
    updateGuildBattleAndWeekComparison();   // ★ 編輯完，重比對
  }
}

    
// V16更新 刪除「全部成員」中的某個成員，全部更動
function deleteMember(id) {
  const m = allMembers.find(x => x.id === id);
  if (!m) return;
  if (!confirm(`確定要刪除「${m.name}」嗎？`)) return;
  const name = m.name;
  // 1) 從 allMembers 中移除
  allMembers = allMembers.filter(x => x.id !== id);
  // 2) 把本週名單與替補名單裡同名成員清空
const nameInputs = document.querySelectorAll(
  '#thisWeek input[data-role="name"], #subsList .sub-name'
);
nameInputs.forEach(input => {
  if ((input.value || "").trim() !== name) return;
  // ----- 本週名單：名字在上一列、技能在下一列 -----
  if (input.dataset.side === "this" && input.dataset.role === "name") {
    // 直接用現成的清除工具，會一起清名字、技能、狀態、skill-has
    clearInputAndSkill(input);
  // ----- 替補名單：名字和技能在同一列 -----
  } else if (input.classList.contains("sub-name")) {
    const row = input.closest(".substitute-row");
    input.value = "";
    if (row) {
      const subSkill = row.querySelector(".sub-skill");
      if (subSkill) subSkill.value = "";
    }
  }
});


  // 3) 從幫會職位欄位移除該成員標籤
  const guildTags = document.querySelectorAll(".guild-box .position-tag");
  guildTags.forEach(tag => {
    if ((tag.dataset.name || "").trim() === name) {
      tag.remove();
    }
  });
  // 重新補幫眾空位
  maintainGuildBattlePlaceholders();
  // 4) 重畫左側全部成員列表 & 替補分頁
  renderMemberList();
  updateSubsPager();
  // 5) 重跑幫眾 vs 本週名單比對
  updateGuildBattleAndWeekComparison();
  // 6) 存檔
  saveState();
}

// V17★ 統一幫「學徒標籤」加上圓形狀態圖示
// ★ 在學徒標籤上加上對應狀態的圓形圖示
function applyWeekStatusIconToTag(tag, status) {
  if (!tag) return;
  // 先清掉舊的圖示
  const old = tag.querySelector(".tag-status-icon");
  if (old) old.remove();
  // 沒有狀態 或 是 present，就不用加圖示
  if (!status || status === "present") return;
  const span = document.createElement("span");
  span.className = "tag-status-icon";
  if (status === "absent") {
    span.textContent = "！";
  } else if (status === "unsure") {
    span.textContent = "？";
  }
  // 插到標籤的最後（或你有 remove 按鈕可以插在前面）
  tag.appendChild(span);
}



    function showDragPreview(text, color){
      dragPreviewEl = document.createElement("div");
      dragPreviewEl.className = "drag-preview";
      dragPreviewEl.textContent = text;
      dragPreviewEl.style.background = color || "#0f172a";
      document.body.appendChild(dragPreviewEl);
      document.addEventListener("dragover", movePreview);
    }
    function movePreview(e){ if(dragPreviewEl){ dragPreviewEl.style.left = e.pageX + 10 + "px"; dragPreviewEl.style.top = e.pageY + 10 + "px"; } }
    function hideDragPreview(){
      if(dragPreviewEl){
        document.body.removeChild(dragPreviewEl);
        dragPreviewEl = null;
        document.removeEventListener("dragover", movePreview);
      }
    }

    function dragFromMemberList(e, m){
      dragSourceSide = "thisWeek";   // ★ V18.1記錄從本週名單拖曳
      e.dataTransfer.setData("text/plain", JSON.stringify(m));
      const color = m.job && roleColors[m.job] ? darkenHex(roleColors[m.job],0.25) : "#0f172a";
      showDragPreview(`${m.name} (${m.job||""})`, color);
      blockNextClick = true;  // v15新增 ✅ 方案 A：這次拖曳結束後若瀏覽器補打一個 click，就把那次 click 擋掉
    }
    
    function dragFromSub(e){
      dragSourceSide = "thisWeek";   // ★ V18.1記錄從本週名單拖曳
      const row = e.currentTarget;
      const name = row.querySelector(".sub-name").value.trim();
      const skill = row.querySelector(".sub-skill").value.trim();
      if(!name){ e.preventDefault(); return; }
      const job = getJobByName(name) || row.querySelector(".sub-name").dataset.job || "";
      e.dataTransfer.setData("text/plain", JSON.stringify({name, skill, job, fromSub: row.dataset.subIndex}));
      const color = job && roleColors[job] ? darkenHex(roleColors[job],0.25) : "#0f172a";
      showDragPreview(`${name} (${job||""})`, color);
      blockNextClick = true;  // v15新增 ✅ 拖完這格之後，下一個 click 不要觸發 input 的 onclick
    }


function dragFromPanel(e) {
  closeMemberPicker(); // ★開始拖曳時先關掉搜尋框
  dragSourceSide = "thisWeek";   // ★ V18.1記錄從本週名單拖曳
  const input = e.target;
  // ★ 記錄拖曳來源是哪一個區塊
  dragSourceSide = input.dataset.side || "";
  // 現在只有本週面板，直接取 side（實際只會是 "this"）
  const side = input.dataset.side;
  const name = input.value.trim();
  // 同列下一行是技能列，把技能一起帶出去
  let skill = "";
  const skillRow = input.parentElement.nextElementSibling;
  if (skillRow) {
    const skillInput = skillRow.querySelector('input[data-role="skill"]');
    if (skillInput) {
      skill = skillInput.value;
    }
  }
  // v15 新增：拖拉後擋掉下一次 click，避免 iOS 誤點放大
  blockNextClick = true;
  const job = input.dataset.job || getJobByName(name) || "";
  draggingPanelInput = input;
  draggingPanelSide = side;
  dragSuccess = false;

  e.dataTransfer.setData(
    "text/plain",
    JSON.stringify({ name, skill, job, fromPanel: true, side })
  );
  const color =
    job && roleColors[job] ? darkenHex(roleColors[job], 0.25) : "#0f172a";
  showDragPreview(
    `${name || "空欄位"} ${job ? "(" + job + ")" : ""}`,
    color
  );
}

/*V16新增比對偵測*/
    document.addEventListener("dragend", function(){
  hideDragPreview();
  if (draggingPanelInput && !dragSuccess) {
    clearInputAndSkill(draggingPanelInput);
    saveState();
    // ★ 若是本週名單欄位 → 重新比對
    if (draggingPanelInput.dataset.side === "this" &&
        draggingPanelInput.dataset.role === "name") {
      updateGuildBattleAndWeekComparison();
    }
  }
  draggingPanelInput = null;
  draggingPanelSide = null;
});


    
   /*下方v15擋掉點擊避免zoom in*/
// ✅ 方案 A：阻止「點擊」，不阻止拖曳
// 拖曳開始時把這個 flag 打開，下一次 click 先被我們攔截掉，才不會誤觸搜尋框 / 聚焦
let blockNextClick = false;
document.addEventListener(
  "click",
  function (e) {
    if (!blockNextClick) return;
    const t = e.target;
    // 用掉這次機會，下一次 click 恢復正常
    blockNextClick = false;
    // 👉 本週名單名字欄位：不要攔截，讓 onclick 正常觸發 onNameCellClick → cycleCellStatus
    if (t.matches('#thisWeek input[data-role="name"]')) {
      return; // 直接放行，不 preventDefault / stopPropagation
    }
    // 👉 只保留「替補欄位」的防誤觸行為
    if (t.matches('#subsList .sub-name')) {
      const val = (t.value || "").trim();
      // 已經有名字時，吃掉這次 click，避免拖曳後誤觸聚焦 / 放大
      if (val) {
        e.preventDefault();
        e.stopPropagation();
      }
      // 空欄位則放行（可以點進去輸入）
    }
  },
  true
);
/*上方v15擋掉點擊避免zoom in*/

    
    function allowDrop(ev){ ev.preventDefault(); }

    function getJobByName(name){
      const m = allMembers.find(x=>x.name===name);
      return m ? m.job : "";
    }

    /*V18修改，交換不改名字職業色*/
    function applyJobColor(input, job){
  if (!input) return;
  if (job && roleColors[job]) {
    const dark = darkenHex(roleColors[job], 0.25);
    // 只設定左邊職業條顏色
    input.style.borderLeft = "6px solid " + dark;
    input.dataset.job = job;
  } else {
    // 沒職業就清掉職業條
    input.style.borderLeft = "";
    input.dataset.job = "";
  }
  // 如果你希望名字維持粗體，可以留著這行：
  input.style.fontWeight = "700";
}

    function applyColorByName(input){
      const name = input.value.trim();
      const job = getJobByName(name);
      applyJobColor(input, job);
    }

    function setSkillInputValue(input, val) {
      if (!input) return;
      input.value = val || "";
      if (val && val.trim() !== "") input.classList.add("skill-has");
      else input.classList.remove("skill-has");
    }

    

// V18.2：顯示成員原本所在的「團名 + 小隊」
function clearDuplicateInPanel(panelEl, name, exceptInput){
  let cleared = false;
  let fromText = "";  // 原本在哪一團、哪一小隊
  panelEl.querySelectorAll("input[data-role='name']").forEach(inp => {
    if (inp !== exceptInput && inp.value.trim() === name) {
      // 清掉前先記錄舊位置（例如：進攻 第2小隊）
      fromText = getGroupAndSquad(inp);
      clearInputAndSkill(inp);
      cleared = true;
    }
  });
  // 有真的清到舊位置、而且有新位置可以當錨點，才跳提示
  if (cleared && exceptInput) {
    const msg = fromText
      ? `已從「${fromText}」移到新位置`
      : `已更新「${name}」的位置`;

    // 用新位置那一格當氣泡錨點
    showWeekToast(msg, exceptInput);
  }
}



    function collectDirtyMarks() {
      const marks = [];
      thisWeekPanel.querySelectorAll("[data-dirty='1']").forEach(el => {
        const teamBlock = el.closest(".team-block");
        if (teamBlock) {
          const team = teamBlock.dataset.team;
          if (el.classList.contains("team-tag-select")) {
            marks.push({type:"team-tag", team});
          } else {
            const squadEl = el.closest(".squad");
            if (squadEl) {
              const squadIdx = Array.from(squadEl.parentElement.children).indexOf(squadEl);
              const nameInputs = squadEl.querySelectorAll("input[data-role='name']");
              const memberIdx = Array.from(nameInputs).indexOf(el);
              if (memberIdx !== -1) marks.push({type:"member", team, squad: squadIdx, member: memberIdx});
            }
          }
        }
      });
      thisWeekPanel.querySelectorAll(".team-block").forEach(block => {
        const team = block.dataset.team;
        const squads = block.querySelectorAll(".squad");
        squads.forEach((sqEl, idx) => {
          if (sqEl.dataset.newlyAdded === "1") {
            marks.push({ type: "squadNew", team, squad: idx });
            delete sqEl.dataset.newlyAdded;
          }
        });
        block.dataset.lastSquadCount = String(squads.length);
      });
      subsList.querySelectorAll("[data-dirty='1']").forEach(el => {
        const row = el.closest(".substitute-row");
        if (row) {
          const idx = Array.from(subsList.children).indexOf(row);
          marks.push({type:"sub", index: idx});
        }
      });
      return marks;
    }

// 收集「最近標記」資料：沿用舊版結構 { user, marks }
function collectRecentMarks() {
  const marks = collectDirtyMarks();
  return {
    user: currentUser || "unknown",
    marks
  };
}

    function renderRecentMarks(recentMarks) {
  clearAllOutlines();
  // 編輯期間先不顯示框線，等下一次儲存才畫
  if (outlinesSuppressed) return;
  if (!recentMarks || !recentMarks.user || !recentMarks.marks) return;
  const cls = OUTLINE_CLASS[recentMarks.user] || "outline-dabai";
  recentMarks.marks.forEach(m => {
    if (m.type === "member") {
      const block = thisWeekPanel.querySelector(`.team-block[data-team="${m.team}"]`);
      if (!block) return;
      const sq = block.querySelectorAll(".squads .squad")[m.squad];
      if (!sq) return;
      const inp = sq.querySelectorAll("input[data-role='name']")[m.member];
      if (inp) inp.classList.add(cls);
    } else if (m.type === "team-tag") {
      const block = thisWeekPanel.querySelector(`.team-block[data-team="${m.team}"]`);
      const sel = block && block.querySelector(".team-tag-select");
      if (sel) sel.classList.add(cls);
    } else if (m.type === "sub") {
      const row = subsList.children[m.index];
      if (row) row.classList.add(cls);
    } else if (m.type === "squadNew") {
      const block = thisWeekPanel.querySelector(`.team-block[data-team="${m.team}"]`);
      const newsq = block && block.querySelectorAll(".squad")[m.squad];
      if (newsq) {
        const title = newsq.querySelector(".squad-title");
        if (title) title.classList.add(cls);
      }
    }
  });
}


    function clearAllOutlines(){
      document.querySelectorAll(".outline-dabai, .outline-baoan, .outline-stitch").forEach(el=>{
        el.classList.remove("outline-dabai","outline-baoan","outline-stitch");
      });
    }

    
  function dropMember(ev) {
  ev.preventDefault();
  dragSuccess = true;

  const data = ev.dataTransfer.getData("text/plain");
  if (!data) return;
  const member = JSON.parse(data);
  const target = ev.target;

  // V16★ 先判斷是不是丟到幫會職位大框
    const guildBox = ev.target.closest(".guild-box");
  if (guildBox) {
    // ★ 學徒欄位不接受拖曳
    if (guildBox === guildPendingBox) {
      // 想要有提示就開啟下面這行
      // alert("學徒欄位目前不開放拖曳設定");
      return;
    }
    addGuildTag(guildBox, {
      name: member.name,
      job: member.job || getJobByName(member.name) || ""
    });
    saveState();
    updateGuildBattleAndWeekComparison();   // ★ 編輯完，重比對
    updateSubStatusByThisWeek();
    return;
  }

  // ② 替補區：sub-name
  if (target.classList.contains("sub-name")) {
    const subRow = target.parentElement;
    const subSkillInput = subRow.querySelector(".sub-skill");
    const prevName  = (target.value || "").trim();              // 替補格原本的名字（例如 A）
    const prevSkill = subSkillInput ? (subSkillInput.value || "").trim() : "";
    // ───────── 面板（本週） → 替補 ─────────
    if (member.fromPanel && draggingPanelInput) {
      const fromThisWeek =
        draggingPanelInput.dataset.side === "this" &&
        draggingPanelInput.dataset.role === "name";
      const isTargetEmpty = !prevName;
      // 1）先把「拖來的人」（可能是 A 或 B）放到替補格
      target.value = member.name;
      applyJobColor(target, member.job);
      if (subSkillInput) {
        setSkillInputValue(subSkillInput, member.skill || "");
      }
      markDirty(target);
      fitNameFont(target);
      // 2）如果來源是「本週名單」
      if (fromThisWeek) {
        // 2-1）本週 → 空白替補：只「複製」，不動本週（A 本週還在）
        if (isTargetEmpty) {
          // 不做任何處理，本週來源欄位維持原狀
        } else {
          // 2-2）本週 → 替補（替補原本有人）：執行「交換」邏輯
          const newAName  = prevName;      // 要放回本週的 A 名字
          const newASkill = prevSkill;     // 從替補格帶回 A 的技能
          const newAJob   =
            getJobByName(newAName) ||
            draggingPanelInput.dataset.job ||
            "";
          // 把來源格（原本 B）改成 A
          draggingPanelInput.value = newAName;
          applyJobColor(draggingPanelInput, newAJob);
          const srcSkillRow = draggingPanelInput.parentElement.nextElementSibling;
          if (srcSkillRow) {
            const srcSkillInput = srcSkillRow.querySelector(
              "input[data-role='skill']"
            );
            if (srcSkillInput) {
              setSkillInputValue(srcSkillInput, newASkill || "");
            }
          }
          markDirty(draggingPanelInput);
          // 清掉本週裡其他同名 A，只保留「新 A」（也就是原本 B 的那格）
          if (newAName) {
            clearDuplicateInPanel(thisWeekPanel, newAName, draggingPanelInput);
          }
        }
      }
      //（如果之後有 other side panel，要不要特別處理，可以在這裡加 else 分支）
      saveState();
      updateGuildBattleAndWeekComparison();
      updateSubStatusByThisWeek();   // 更新「已排入本週名單」紅字
      return;
    }
    // ───────── 替補 → 替補：進行交換 ─────────
    if (member.fromSub !== undefined) {
      const srcRow = subsList.querySelector(
        `[data-sub-index="${member.fromSub}"]`
      );
      // 保護一下：來源存在且不是同一列，才做交換
      if (srcRow && srcRow !== subRow) {
        const srcNameInput  = srcRow.querySelector(".sub-name");
        const srcSkillInput = srcRow.querySelector(".sub-skill");
        const srcName  = srcNameInput  ? (srcNameInput.value  || "").trim() : "";
        const srcSkill = srcSkillInput ? (srcSkillInput.value || "").trim() : "";
        const srcJob   =
          (srcNameInput && (srcNameInput.dataset.job || getJobByName(srcName))) ||
          "";
        const tgtName  = prevName;
        const tgtSkill = prevSkill;
        const tgtJob   = target.dataset.job || getJobByName(tgtName) || "";
        // 1）把「目標原本的值」放回來源列（srcRow）
        if (srcNameInput) {
          srcNameInput.value = tgtName;
          applyJobColor(srcNameInput, tgtJob);
          markDirty(srcNameInput);
        }
        if (srcSkillInput) {
          setSkillInputValue(srcSkillInput, tgtSkill || "");
        }
        // 2）把「來源的人（member）」放進目前目標替補格
        target.value = srcName;              // member.name 也應該等於 srcName，這裡用 srcName 比較穩
        applyJobColor(target, srcJob);
        if (subSkillInput) {
          setSkillInputValue(subSkillInput, srcSkill || "");
        }
        markDirty(target);
        saveState();
        updateSubStatusByThisWeek();   // 重新判斷紅字
        return;
      }
      // 如果拖到自己那列，就當沒事發生，繼續往下走（但通常已經 return 不會到這裡）
    }
    // ───────── 其他來源（全部成員名單 等） → 替補 ─────────
    // ✅ 一律「複製」，不動本週名單
    target.value = member.name;
    applyJobColor(target, member.job);
    if (subSkillInput) {
      setSkillInputValue(subSkillInput, member.skill || "");
    }
    markDirty(target);
    // ⚠️ 這裡不要再清除本週的 prevName，避免覆蓋 A 時把本週 A 刪掉
    // if (prevName) {
    //   clearDuplicateInPanel(thisWeekPanel, prevName, null);
    // }
    saveState();
    updateGuildBattleAndWeekComparison();
    updateSubStatusByThisWeek();   // 更新替補紅字狀態
    return;
}


   // ③ 面板格：本週名單（name 欄位）
if (target.dataset && target.dataset.role === "name") {
  const targetSide = target.dataset.side;   // 現在實際只會是 "this"
  // 同面板互換（本週內部互換）
  if (member.fromPanel && member.side === targetSide && draggingPanelInput) {
    const src = draggingPanelInput;
    if (src === target) return;

    // ★ 新增：如果來源是在「本週名單」，先記住他原本是在哪一團第幾小隊
    let fromText = "";
    if (src.dataset.side === "this" && src.dataset.role === "name") {
      fromText = getGroupAndSquad(src);   // 例：進攻 第1小隊
    }
    // 原本來源格資料
    const srcName = src.value.trim();
    const srcJob  = src.dataset.job || getJobByName(srcName) || "";
    let srcSkill  = "";
    const srcSkillRow = src.parentElement.nextElementSibling;
    if (srcSkillRow) {
      const srcSkillInput = srcSkillRow.querySelector("input[data-role='skill']");
      if (srcSkillInput) {
        srcSkill = srcSkillInput.value;
      }
    }
    // 目標格資料
    const tgtName = target.value.trim();
    const tgtJob  = target.dataset.job || getJobByName(tgtName) || "";
    let tgtSkill  = "";
    const tgtSkillRow = target.parentElement.nextElementSibling;
    if (tgtSkillRow) {
      const tgtSkillInput = tgtSkillRow.querySelector("input[data-role='skill']");
      if (tgtSkillInput) {
        tgtSkill = tgtSkillInput.value;
      }
    }
    // ⭐ 把兩格目前的狀態也記起來（可能為空字串 = 沒狀態）
    const srcStatus = src.dataset.status || "";
    const tgtStatus = target.dataset.status || "";
    // 互換名字 & 顏色
    src.value = tgtName;
    applyJobColor(src, tgtJob);
    target.value = srcName;
    applyJobColor(target, srcJob);
    // 互換技能
    if (srcSkillRow) {
      const srcSkillInput = srcSkillRow.querySelector("input[data-role='skill']");
      if (srcSkillInput) {
        setSkillInputValue(srcSkillInput, tgtSkill || "");
      }
    }
    if (tgtSkillRow) {
      const tgtSkillInput = tgtSkillRow.querySelector("input[data-role='skill']");
      if (tgtSkillInput) {
        setSkillInputValue(tgtSkillInput, srcSkill || "");
      }
    }
    // ⭐ 互換 / 清理狀態
    // 1）原本目標格若是空白，互換後「來源格」應該變成真正的空格：直接 reset
    if (!tgtName) {
      resetCellStatus(src);
    } else {
      // 有名字的格子才套狀態；若原本沒狀態就清掉
      if (tgtStatus) {
        setCellStatus(src, tgtStatus);
      } else {
        resetCellStatus(src);
      }
    }
    // 2）原本來源格若有名字，互換到「目標格」，狀態跟著人走；沒有狀態就清空
    if (!srcName) {
      resetCellStatus(target);
    } else {
      if (srcStatus) {
        setCellStatus(target, srcStatus);
      } else {
        resetCellStatus(target);
      }
    }
    // 清掉比對用標示
    src.classList.remove("highlight-new", "highlight-missing");
    target.classList.remove("highlight-new", "highlight-missing");
    markDirty(src);
    markDirty(target);
    // ★ V18.2本週名單內互換欄位後，重算一次跑馬燈
    setTimeout(updateAllThisWeekMarquee, 0);
    // ★ 新增：如果是「本週 → 本週」，在目標格上方顯示「從哪一團第幾小隊移過來」
    if (
      fromText &&                         // 有成功抓到團名＋小隊
      target.dataset.side === "this" &&   // 目標在本週名單
      target.dataset.role === "name"
    ) {
      showWeekToast(`已從「${fromText}」移到新位置`, target);
    }
    saveState();
    updateGuildBattleAndWeekComparison();   // ★ 編輯完，重比對
    return;
  }

    // 替補 → 面板且目標格原本有值：把舊值放回替補
    if (member.fromSub !== undefined && target.value.trim() !== "") {
      const oldName = target.value.trim();
      const oldJob  = target.dataset.job || getJobByName(oldName) || "";
      let oldSkill  = "";
      const skillRow = target.parentElement.nextElementSibling;
      if (skillRow) {
        const skillInput = skillRow.querySelector("input[data-role='skill']");
        if (skillInput) {
          oldSkill = skillInput.value;
        }
      }
      const subRow = subsList.querySelector(`[data-sub-index="${member.fromSub}"]`);
      if (subRow) {
        const subNameInput  = subRow.querySelector(".sub-name");
        const subSkillInput = subRow.querySelector(".sub-skill");
        if (subNameInput) {
          subNameInput.value = oldName;
          applyJobColor(subNameInput, oldJob);
          markDirty(subNameInput);
        }
        if (subSkillInput) {
          subSkillInput.value = oldSkill;
        }
      }
    }
    // ⭐ 真正放進面板
    target.value = member.name;
    applyJobColor(target, member.job);
    const srow = target.parentElement.nextElementSibling;
    if (srow) {
      const skillInput = srow.querySelector("input[data-role='skill']");
      if (skillInput) {
        setSkillInputValue(skillInput, member.skill ? member.skill : "");
      }
    }
 
// ★ 本週名單內互換欄位後，重算一次跑馬燈
    setTimeout(updateAllThisWeekMarquee, 0);

   // V18.1★★★★★ 進來本週名單 → 自動變成「未上線」狀態
target.dataset.status = "absent";
// 名字欄位所在列（member-row）
const row = target.closest(".member-row");
// 先把舊狀態 class 清掉
row.classList.remove("status-present","status-late","status-unsure","status-absent");
// 套上未上線狀態（灰色）
row.classList.add("status-absent");


    // 清掉本週面板裡重複的名字（保留這個 target）
    clearDuplicateInPanel(thisWeekPanel, member.name, target);
    // 清掉比對標示
    target.classList.remove("highlight-new", "highlight-missing");

    markDirty(target);
    saveState();
    updateGuildBattleAndWeekComparison();   // ★ 編輯完，重比對
    updateSubStatusByThisWeek();
  }
}

    function getPanelData(panelEl){
      const data = [];
      panelEl.querySelectorAll(".team-block").forEach(block=>{
        const team = block.dataset.team;
        const tagSelect = block.querySelector(".team-tag-select");
        const label = block.querySelector(".team-tag-label");
        const groupTag = tagSelect ? tagSelect.value : (label ? label.textContent.trim() : "一團");
        const squads = [];
        block.querySelectorAll(".squads .squad").forEach(sq=>{
          const members = [];
          sq.querySelectorAll("input[data-role='name']").forEach(nameInput=>{
            const skillRow = nameInput.parentElement.nextElementSibling;
            const skillInput = skillRow ? skillRow.querySelector("input[data-role='skill']") : null;
            members.push({
              name: nameInput.value.trim(),
              job: nameInput.dataset.job || "",
              skill: skillInput ? (skillInput.value.trim() || "") : "",
              status: nameInput.dataset.status || ""   // ★ 新增
            });
          });
          squads.push({members});
        });
        data.push({team, tag: groupTag, squads});
      });
      return data;
    }

function setPanelData(panelEl, data, side) {
  if (!panelEl || !data) return;
  data.forEach(teamData => {
    const block = panelEl.querySelector(`.team-block[data-team="${teamData.team}"]`);
    if (!block) return;
    // 團別下拉選單（進攻 / 拆塔 / 防守 ...）
    const tagSelect = block.querySelector(".team-tag-select");
    if (tagSelect && teamData.tag) {
      tagSelect.value = teamData.tag;
    }
    const squadsContainer = block.querySelector(".squads");
    const neededCount = teamData.squads.length;
    let currentCount = squadsContainer.children.length;
    // 小隊數量不足就補
    while (currentCount < neededCount) {
      squadsContainer.appendChild(
        createSquad(currentCount + 1, side, teamData.team)
      );
      currentCount++;
    }
    // 小隊太多就砍掉尾巴
    while (squadsContainer.children.length > neededCount) {
      squadsContainer.removeChild(squadsContainer.lastElementChild);
    }
    // 套入每一隊、每一格成員資料
    teamData.squads.forEach((sqData, idx) => {
      const sqEl = squadsContainer.children[idx];   // ★ 一定要在這裡宣告 sqEl
      if (!sqEl) return;
      const nameInputs = sqEl.querySelectorAll('input[data-role="name"]');
      nameInputs.forEach((inp, mIdx) => {
        const member = sqData.members[mIdx];
        if (member && (member.name || "").trim() !== "") {
          // 名字
          inp.value = member.name || "";

          // 職業顏色
          const job = member.job || getJobByName(member.name) || "";
          if (job) {
            applyJobColor(inp, job);
          } else {
            applyColorByName(inp);
          }
          // 技能欄
          const skillRow = inp.parentElement.nextElementSibling;
          if (skillRow) {
            const skillInput = skillRow.querySelector('input[data-role="skill"]');
            if (skillInput) {
              setSkillInputValue(skillInput, member.skill ? member.skill : "");
            }
          }
          // ★ V17：還原出席狀態
          // 舊資料沒有 status 的話，預設視為「未上線」或「已出席」都可以，你自己選：
          const st = member.status || "absent";   // 改成 "present" = 舊資料視為有出席
          setCellStatus(inp, st);
        } else {
          // 該格沒人 → 清空名字與技能 + 清掉狀態
          clearInputAndSkill(inp);
          resetCellStatus(inp);   // 空格＝完全無狀態
        }
      });
    });
    // 重新編號小隊＋調整寬度
    renumberSquads(block);
    block.dataset.lastSquadCount = String(neededCount || 3);
    adjustSquadWidths(block);
  });
}


//V16新增
// 只記錄「幫眾欄」的狀態，學徒欄不入庫
function getGuildPositionsData() {
  const battle = [];
  if (guildBattleBox) {
    guildBattleBox.querySelectorAll(".position-tag").forEach(tag => {
      const name = (tag.dataset.name || "").trim();
      if (!name) return;
      const job = tag.dataset.job || getJobByName(name) || "";
      battle.push({ name, job });
    });
  }
  return { battle };   // ★ 沒有 pending 了
}




    function getSubsData(){
      const arr = [];
      subsList.querySelectorAll(".substitute-row").forEach(row=>{
        arr.push({ name: row.querySelector(".sub-name").value.trim(), skill: row.querySelector(".sub-skill").value.trim() });
      });
      return arr;
    }

    // V19新版：存 localStorage，同時排程自動儲存到 Firebase
function saveState() {
  dbg("saveState()", {
    from: "local-change",
    // 簡化一下，不要整包 allMembers 印出來
    thisWeekPreview: getPanelData(thisWeekPanel).map(t => ({
      team: t.team,
      squads: t.squads.length
    }))
  });
  const state = {
    allMembers,
    thisWeek: getPanelData(thisWeekPanel),
    subs: getSubsData(),
    guildPositions: getGuildPositionsData(),
    // 把標記一起存進去，結構跟 doSaveToBackend 一致
    recentMarks: collectRecentMarks()
  };
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  } catch (e) {
    console.error(e);
  }
  // ★ 新增：每次有變動就排程自動同步到雲端
  scheduleAutoSaveToCloud(state);
}

// ★ V20 把 thisWeek 陣列，拆成以「團名」為 key 的物件，方便分團儲存
function extractThisWeekByTeams(thisWeekArray) {
  const result = {};
  if (!Array.isArray(thisWeekArray)) return result;
  thisWeekArray.forEach((team) => {
    if (!team || !team.team) return;
    result[team.team] = {
      tag: team.tag || "",
      squads: Array.isArray(team.squads) ? team.squads : []
    };
  });
  return result;
}



// ★ v21：簡化版自動儲存（每次觸發都重新讀目前畫面）
let autoSaveTimer = null;
function scheduleAutoSaveToCloud(stateOverride) {
  if (typeof stateDocRef === "undefined" || !stateDocRef) return;
  // debounce：0.8 秒內多次變更合併成一次
  if (autoSaveTimer) clearTimeout(autoSaveTimer);
  autoSaveTimer = setTimeout(async () => {
    autoSaveTimer = null;
    const now = firebase.firestore.FieldValue.serverTimestamp();
    try {
      // 1) 每次觸發時「重新抓一次畫面狀態」
      const state =
        stateOverride ||
        {
          allMembers,
          thisWeek: getPanelData(thisWeekPanel),
          subs: getSubsData(),
          guildPositions: getGuildPositionsData(),
          recentMarks: collectRecentMarks()
        };
      // 2) 用「目前 thisWeek」拆出四團資料
      const teamsData = extractThisWeekByTeams(state.thisWeek || []);
      dbg("AutoSave TIMER FIRE", {
        teamsPreview: Object.keys(teamsData)
      });
      // 3) 寫入四個團的 document
      for (const teamName in teamDocRefs) {
        const ref = teamDocRefs[teamName];
        if (!ref) continue;
        const team = teamsData[teamName] || {
          tag: teamName === "進攻" || teamName === "拆塔" ? "一團" : "二團",
          squads: []
        };
        await ref.set(
          {
            tag: team.tag || "",
            squads: Array.isArray(team.squads) ? team.squads : [],
            updatedAt: now
          },
          { merge: true }
        );
      }
      dbg("CloudWrite TEAMS done", teamsData);
      // 4) 只更新「核心資料」，不動 thisWeek（thisWeek 完全交給 teams/*）
      await stateDocRef.set(
        {
          "payload.allMembers": state.allMembers,
          "payload.subs": state.subs,
          "payload.guildPositions": state.guildPositions,
          "payload.recentMarks": state.recentMarks,
          updatedAt: now
        },
        { merge: true }
      );
      dbg("CloudWrite CORE done", {
        allMembersCount: (state.allMembers || []).length
      });
      if (typeof lastKnownUpdatedAt !== "undefined") {
        lastKnownUpdatedAt = Date.now();
      }
    } catch (err) {
      console.warn("自動儲存到雲端失敗（分團寫入）", err);
    }
  }, 800);
}









    function fetchWithTimeout(url, ms=3000){
      const ctrl = new AbortController();
      const id = setTimeout(()=>ctrl.abort(), ms);
      return fetch(url, {signal: ctrl.signal}).finally(()=>clearTimeout(id));
    }

    /* 本週所有名字 Set（含空白濾除） */
    function getThisWeekNameSet(){
      const set = new Set();
      thisWeekPanel.querySelectorAll("input[data-role='name']").forEach(inp=>{
        const v = inp.value.trim(); if(v) set.add(v);
      });
      return set;
    }

    function applyStateToPage(state, fromLocal){
      dbg("applyStateToPage()", {
    fromLocal,
    allMembers: state.allMembers ? state.allMembers.length : 0,
    thisWeek: (state.thisWeek || []).map(t => ({
      team: t.team,
      squads: t.squads ? t.squads.length : 0
    }))
  });
      if (state.allMembers && Array.isArray(state.allMembers)) {
        allMembers = state.allMembers;
        const maxId = allMembers.reduce((m,c)=>Math.max(m,c.id||0),12);
        nextMemberId = maxId + 1;
      }
      renderMemberList();
      renderRoleTabs();
      if (state.thisWeek) {
  setPanelData(thisWeekPanel, state.thisWeek, "this");
  thisWeekPanel.querySelectorAll(".team-block").forEach(adjustSquadWidths);
}

/* V16★ 還原幫會職位欄位（只還原幫眾） */
if (guildBattleBox) {
  guildBattleBox.innerHTML = "";
  guildBattleBox.classList.add("empty");
}
if (guildPendingBox) {
  // 學徒欄每次都由比對重新產生，不做還原
  guildPendingBox.innerHTML = "";
  guildPendingBox.classList.add("empty");
}
if (state.guildPositions && guildBattleBox) {
  const gp = state.guildPositions;
  const battle = gp.battle || [];
  battle.forEach(m => {
    addGuildTag(
      guildBattleBox,
      { name: m.name, job: m.job },
      { bypassRules: true }   // 還原資料，不做 60 人上限 & 去重
    );
  });
  if (guildBattleBox.querySelector(".position-tag")) {
    guildBattleBox.classList.remove("empty");
  }
}// ★ 學徒欄不還原，等 loadState() 結尾的 updateGuildBattleAndWeekComparison() //    依據「幫眾」＋「本週名單」重新算出學徒名單


subsList.innerHTML = "";
if (state.subs && state.subs.length) {
  state.subs.forEach(su => createSubRow(su.name, su.skill, false));
}
refreshSubsView();
updateSubStatusByThisWeek();   // ⭐ 在這裡加入（渲染完替補後執行）
    }


// V19-Firebase：現在改成自動儲存，這個函式只負責顯示提示／呼叫 callback
function requestSave(options = {}) {
  const { silent = false, onSuccess = null } = options;
  // 不再做登入、不再主動打後端，因為 saveState 會自動同步到 Firebase
  if (!silent) {
    // 用你現有的 Toast（或之後你想改成別的字都可以）
    if (typeof showWeekToast === "function") {
      showWeekToast("✅ 現在是自動儲存模式，不用按「儲存」");
    } else {
      console.log("現在是自動儲存模式，不用按「儲存」");
    }
  }
  // 如果呼叫方有傳 onSuccess，就直接幫它執行（當作「已完成」）
  if (typeof onSuccess === "function") {
    onSuccess();
  }
}




    function showLogin(){
      document.getElementById("loginMsg").textContent = "";
      document.getElementById("loginUser").value = "";
      document.getElementById("loginPass").value = "";
      document.getElementById("loginModal").style.display = "flex";
      document.getElementById("loginUser").focus();
    }
    function closeLogin(){ document.getElementById("loginModal").style.display = "none"; }

    function doLogin(){
      const u = document.getElementById("loginUser").value.trim();
      const p = document.getElementById("loginPass").value.trim();
      fetch(REMOTE_API, {
        method: "POST",
        body: JSON.stringify({ action: "login", user: u, pass: p })
      })
      .then(r => r.json())
      .then(data => {
        if (data && data.success && data.user) {
          currentUser = data.user;
          lastLoginTime = Date.now();
          localStorage.setItem(LOGIN_STORAGE_KEY, JSON.stringify({user: currentUser, time: lastLoginTime}));
          closeLogin();
          doSaveToBackend();
        } else {
          document.getElementById("loginMsg").textContent = "帳號或密碼錯誤";
        }
      })
      .catch(err => {
        console.warn("login error", err);
        document.getElementById("loginMsg").textContent = "登入失敗";
      });
    }

function doSaveToBackend() {
  // 這裡的 state 就是要存到雲端的完整狀態
  const state = {
    allMembers,
    thisWeek: getPanelData(thisWeekPanel),
    subs: getSubsData(),
    guildPositions: getGuildPositionsData(),  // ★ 把幫眾 / 學徒也存進去
    recentMarks: collectRecentMarks()        // 你新版用的標記資料
  };

  // 先存一份 localStorage 備份（延續你現在的做法）
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  } catch (e) {
    console.error(e);
  }

  // V19 使用 Firestore 儲存到固定文件
  showLoadingMask();
  stateDocRef
    .set(
      {
        payload: state,
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      },
      { merge: true }
    )
    .then(() => {
      hideLoadingMask();
      const silent = !!requestSave._silentOnce;
      const cb = requestSave._onSuccess;
      // 這裡的 updatedAt 我們就先用現在時間記錄在本地
      lastKnownUpdatedAt = Date.now();

      if (!silent) {
        alert("已儲存到雲端（Firebase）");
      }
      requestSave._silentOnce = false;
      requestSave._onSuccess = null;
      if (typeof cb === "function") cb();
    })
    .catch((err) => {
      hideLoadingMask();
      alert("儲存到雲端失敗，請檢查網路或 Firebase 設定");
      console.error(err);
    });
}


//V20 改成「不要再用 payload.thisWeek 重蓋整包」
function startVersionWatcher() {
  // 只註冊一次監聽目前這一份主文件
  stateDocRef.onSnapshot(
    (doc) => {
      if (!doc.exists) return;
      const data = doc.data();
      dbg("VersionWatcher fired", {
      hasPayload: !!data.payload,
      updatedAt: data.updatedAt ? data.updatedAt.toMillis?.() : null
    });
      if (!data) return;
      // 目前仍以 payload 為主（與既有結構相容）
      const cloudState = data.payload || {};
      // 我們只比較「非 thisWeek」的部分，避免別人整包 thisWeek 把本機蓋掉
      let cloudShared = cloudState;
      try {
        const { thisWeek, ...rest } = cloudState || {};
        cloudShared = rest;
      } catch (e) {}
      try {
        const currentLocalRaw = localStorage.getItem(STORAGE_KEY);
        if (currentLocalRaw) {
          const currentLocal = JSON.parse(currentLocalRaw) || {};
          const { thisWeek: localThisWeek, ...localShared } = currentLocal;
          // 如果非 thisWeek 部分完全一樣，就略過（避免重複重畫）
          if (sameJSON(localShared, cloudShared)) {
            return;
          }
        }
      } catch (e) {
        // ignore JSON error
      }
      // 準備要套用到畫面的 state：
      // 1. 先以 cloudState 為主
      // 2. 保留本機 thisWeek（讓本週名單之後交給 teams doc 來即時同步）
      let mergedState = cloudState;
      try {
        const currentLocalRaw = localStorage.getItem(STORAGE_KEY);
        if (currentLocalRaw) {
          const currentLocal = JSON.parse(currentLocalRaw) || {};
          mergedState = Object.assign({}, cloudState, {
            thisWeek: currentLocal.thisWeek || cloudState.thisWeek
          });
        }
      } catch (e) {
        // 如果解析失敗，就直接用 cloudState
        mergedState = cloudState;
      }
      // 套用到畫面（fromLocal = false）
      applyStateToPage(mergedState, false);
      // 更新本機 localStorage（包含保留下來的 thisWeek）
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(mergedState));
      } catch (e) {}
      // 記錄最新更新時間，避免之後誤判舊資料
      try {
        if (data.updatedAt && typeof data.updatedAt.toMillis === "function") {
          lastKnownUpdatedAt = data.updatedAt.toMillis();
        } else if (typeof lastKnownUpdatedAt !== "undefined") {
          lastKnownUpdatedAt = Date.now();
        }
      } catch (e) {
        // ignore
      }
      // 保留原本的提示與更新
      try {
        showWeekToast("✅ 已同步最新雲端資料");
      } catch (e) {
        // showWeekToast 若需要 anchor 但沒傳，就忽略
        console.log("已同步最新雲端資料");
      }
      updateGuildBattleAndWeekComparison();
      maintainGuildBattlePlaceholders();
    },
    (err) => {
      console.warn("Firestore 版本監聽錯誤", err);
    }
  );
}

// V21：各團即時監聽，只更新「本週名單」這一塊，不再整頁重畫
function startTeamWatchers() {
  if (typeof teamDocRefs === "undefined") return;
  const teamNames = ["進攻", "拆塔", "機動", "防守"];
  teamNames.forEach((teamName) => {
    const ref = teamDocRefs[teamName];
    if (!ref) return;
    ref.onSnapshot(
      (snap) => {
        if (!snap.exists) return;
        const data = snap.data() || {};
        if (!Array.isArray(data.squads)) return;
        dbg("TeamWatcher fired", {
          team: teamName,
          squads: data.squads.length,
          pending: snap.metadata && snap.metadata.hasPendingWrites
        });

        // 1) 先從畫面抓「目前的 thisWeek」（含其他人的變更、以及自己當前的編輯）
        const currentThisWeek = getPanelData(thisWeekPanel) || [];
        // 2) 轉成以 teamName 為 key 的 map
        const byTeam = {};
        currentThisWeek.forEach((t) => {
          if (!t || !t.team) return;
          byTeam[t.team] = {
            team: t.team,
            tag: t.tag || "",
            squads: Array.isArray(t.squads) ? t.squads : []
          };
        });
        // 3) 確保四個團都有基本殼
        const allTeamNames = ["進攻", "拆塔", "機動", "防守"];
        allTeamNames.forEach((name) => {
          if (!byTeam[name]) {
            byTeam[name] = {
              team: name,
              tag: name === "進攻" || name === "拆塔" ? "一團" : "二團",
              squads: []
            };
          }
        });
        // 4) 用 Firestore 的最新資料覆蓋「這一團」
        byTeam[teamName].squads = Array.isArray(data.squads) ? data.squads : [];
        if (data.tag) {
          byTeam[teamName].tag = data.tag;
        }
        // 5) 組回 thisWeek 陣列，固定順序
        const newThisWeek = allTeamNames.map((name) => byTeam[name]);
        // 6) 只更新「本週名單」畫面，不動全部成員 / 幫會職位
        setPanelData(thisWeekPanel, newThisWeek, "this");
        thisWeekPanel.querySelectorAll(".team-block").forEach(adjustSquadWidths);
        // 7) 更新 localStorage 裡的 thisWeek（讓重整有最新資料）
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          const saved = raw ? JSON.parse(raw) : {};
          saved.thisWeek = newThisWeek;
          localStorage.setItem(STORAGE_KEY, JSON.stringify(saved));
        } catch (e) {
          console.warn("更新 localStorage 失敗（team watcher）", e);
        }
        // 8) 補上你原本有的比對 / placeholder 維護
        updateGuildBattleAndWeekComparison();
        maintainGuildBattlePlaceholders();
      },
      (err) => {
        console.warn("各團即時監聽錯誤", err);
      }
    );
  });
}




    function fillRoundRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
      ctx.fill();
    }
  // 只描邊圓角矩形（搭配 fillRoundRect 使用）
function strokeRoundRect(ctx, x, y, w, h, r, color = "#B4BBC8") {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.stroke();
}

    /* V14.6可指定四個角的圓角 path */
function roundRectPath(ctx, x, y, w, h, r, corners = {tl:true,tr:true,br:true,bl:true}) {
  const tl = corners.tl ? r : 0, tr = corners.tr ? r : 0, br = corners.br ? r : 0, bl = corners.bl ? r : 0;
  ctx.beginPath();
  ctx.moveTo(x + tl, y);
  ctx.lineTo(x + w - tr, y);
  if (tr) ctx.quadraticCurveTo(x + w, y, x + w, y + tr); else ctx.lineTo(x + w, y);
  ctx.lineTo(x + w, y + h - br);
  if (br) ctx.quadraticCurveTo(x + w, y + h, x + w - br, y + h); else ctx.lineTo(x + w, y + h);
  ctx.lineTo(x + bl, y + h);
  if (bl) ctx.quadraticCurveTo(x, y + h, x, y + h - bl); else ctx.lineTo(x, y + h);
  ctx.lineTo(x, y + tl);
  if (tl) ctx.quadraticCurveTo(x, y, x + tl, y); else ctx.lineTo(x, y);
  ctx.closePath();
}
function fillRoundRectCorners(ctx, x, y, w, h, r, corners) {
  roundRectPath(ctx, x, y, w, h, r, corners);
  ctx.fill();
}


    
/* 1px 視覺等寬：圓角矩形描邊（像素對齊） */
function strokeRoundedCrisp(ctx, x, y, w, h, r, corners = {tl:true,tr:true,br:true,bl:true}, color = "#B4BBC8") {
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;           // 固定視覺 1px
  ctx.lineJoin = "round";
  ctx.lineCap  = "round";
  // 讓整個外框往右下各對齊半像素，避免曲線被抗鋸齒吃寬
  // 同時縮小 w/h 1px，確保線心都落在像素邊界
  const tl = corners.tl ? r : 0, tr = corners.tr ? r : 0, br = corners.br ? r : 0, bl = corners.bl ? r : 0;
  const _x = x + 0.5, _y = y + 0.5, _w = Math.max(0, w - 1), _h = Math.max(0, h - 1);
  const _r = Math.max(0, r - 0.5);
  ctx.beginPath();
  ctx.moveTo(_x + (corners.tl ? _r : 0), _y);
  ctx.lineTo(_x + _w - (corners.tr ? _r : 0), _y);
  if (tr) ctx.arcTo(_x + _w, _y, _x + _w, _y + (tr ? _r : 0), _r); else ctx.lineTo(_x + _w, _y);
  ctx.lineTo(_x + _w, _y + _h - (corners.br ? _r : 0));
  if (br) ctx.arcTo(_x + _w, _y + _h, _x + _w - (br ? _r : 0), _y + _h, _r); else ctx.lineTo(_x + _w, _y + _h);
  ctx.lineTo(_x + (corners.bl ? _r : 0), _y + _h);
  if (bl) ctx.arcTo(_x, _y + _h, _x, _y + (bl ? _r : 0), _r); else ctx.lineTo(_x, _y + _h);
  ctx.lineTo(_x, _y + (corners.tl ? _r : 0));
  if (tl) ctx.arcTo(_x, _y, _x + (tl ? _r : 0), _y, _r); else ctx.lineTo(_x, _y);
  ctx.stroke();
  ctx.restore();
}


    

/* 1px 視覺等寬：只畫指定邊（像素對齊直線） */
function strokeEdgesCrisp(ctx, x, y, w, h, edges, color = "#B4BBC8") {
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;           // 固定視覺 1px
  ctx.beginPath();
  // 直線都落在 0.5 offset，確保銳利
  if (edges.top)    { ctx.moveTo(x + 0.5, y + 0.5);         ctx.lineTo(x + w - 0.5, y + 0.5); }
  if (edges.right)  { ctx.moveTo(x + w - 0.5, y + 0.5);     ctx.lineTo(x + w - 0.5, y + h - 0.5); }
  if (edges.bottom) { ctx.moveTo(x + 0.5, y + h - 0.5);     ctx.lineTo(x + w - 0.5, y + h - 0.5); }
  if (edges.left)   { ctx.moveTo(x + 0.5, y + 0.5);         ctx.lineTo(x + 0.5, y + h - 0.5); }
  ctx.stroke();
  ctx.restore();
}

    
//以下這段 V14.7 下載圖片功能（含圓角友善描邊 / 視覺等粗）
// ================== 1) 工具：像素對齊描邊 ==================
function strokeRoundedCrisp(ctx, x, y, w, h, r, corners = {tl:true,tr:true,br:true,bl:true}, color = "#B4BBC8") {
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.lineJoin = "round";
  ctx.lineCap  = "round";

  const tl = corners.tl ? r : 0, tr = corners.tr ? r : 0, br = corners.br ? r : 0, bl = corners.bl ? r : 0;
  const _x = x + 0.5, _y = y + 0.5, _w = Math.max(0, w - 1), _h = Math.max(0, h - 1);
  const _rtl = Math.max(0, tl - 0.5), _rtr = Math.max(0, tr - 0.5), _rbr = Math.max(0, br - 0.5), _rbl = Math.max(0, bl - 0.5);

  ctx.beginPath();
  // top
  ctx.moveTo(_x + (tl ? _rtl : 0), _y);
  ctx.lineTo(_x + _w - (tr ? _rtr : 0), _y);
  if (tr) ctx.arcTo(_x + _w, _y, _x + _w, _y + _rtr, _rtr); else ctx.lineTo(_x + _w, _y);
  // right
  ctx.lineTo(_x + _w, _y + _h - (br ? _rbr : 0));
  if (br) ctx.arcTo(_x + _w, _y + _h, _x + _w - _rbr, _y + _h, _rbr); else ctx.lineTo(_x + _w, _y + _h);
  // bottom
  ctx.lineTo(_x + (bl ? _rbl : 0), _y + _h);
  if (bl) ctx.arcTo(_x, _y + _h, _x, _y + _h - _rbl, _rbl); else ctx.lineTo(_x, _y + _h);
  // left
  ctx.lineTo(_x, _y + (tl ? _rtl : 0));
  if (tl) ctx.arcTo(_x, _y, _x + _rtl, _y, _rtl); else ctx.lineTo(_x, _y);
  ctx.stroke();
  ctx.restore();
}

function strokeEdgesCrisp(ctx, x, y, w, h, edges, color = "#B4BBC8") {
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.beginPath();
  if (edges.top)    { ctx.moveTo(x + 0.5, y + 0.5);         ctx.lineTo(x + w - 0.5, y + 0.5); }
  if (edges.right)  { ctx.moveTo(x + w - 0.5, y + 0.5);     ctx.lineTo(x + w - 0.5, y + h - 0.5); }
  if (edges.bottom) { ctx.moveTo(x + 0.5, y + h - 0.5);     ctx.lineTo(x + w - 0.5, y + h - 0.5); }
  if (edges.left)   { ctx.moveTo(x + 0.5, y + 0.5);         ctx.lineTo(x + 0.5, y + h - 0.5); }
  ctx.stroke();
  ctx.restore();
}

// 你已經有的四角圓工具：roundRectPath / fillRoundRectCorners （沿用現成的）
function roundRectPath(ctx, x, y, w, h, r, corners = {tl:true,tr:true,br:true,bl:true}) {
  const tl = corners.tl ? r : 0, tr = corners.tr ? r : 0, br = corners.br ? r : 0, bl = corners.bl ? r : 0;
  ctx.beginPath();
  ctx.moveTo(x + tl, y);
  ctx.lineTo(x + w - tr, y);
  if (tr) ctx.quadraticCurveTo(x + w, y, x + w, y + tr); else ctx.lineTo(x + w, y);
  ctx.lineTo(x + w, y + h - br);
  if (br) ctx.quadraticCurveTo(x + w, y + h, x + w - br, y + h); else ctx.lineTo(x + w, y + h);
  ctx.lineTo(x + bl, y + h);
  if (bl) ctx.quadraticCurveTo(x, y + h, x, y + h - bl); else ctx.lineTo(x, y + h);
  ctx.lineTo(x, y + tl);
  if (tl) ctx.quadraticCurveTo(x, y, x + tl, y); else ctx.lineTo(x, y);
  ctx.closePath();
}
function fillRoundRectCorners(ctx, x, y, w, h, r, corners) {
  roundRectPath(ctx, x, y, w, h, r, corners);
  ctx.fill();
}

// ================== 2) 版面計算 ==================
function getTeamCanvasWidth(team) {
  const basePad = 8;
  const innerGap = 4;
  const squadCount = Math.max(1, (team.squads ? team.squads.length : 0) || 6);
  const squadWidth = 100;
  return basePad * 2 + squadCount * squadWidth + (squadCount - 1) * innerGap;
}

/* 🔹計算團隊外框的「需要高度」，確保能包覆所有小隊 */
function getTeamCanvasHeight(team) {
  // 與 drawTeamBlockImage 內部數值保持一致
  const HEAD_H    = 30; // 頂部色條
  const INNER_PAD = 8;
  const TITLE_H   = 28; // 小隊標題卡
  const NAME_H    = 28; // 名稱卡
  const SKILL_H   = 22; // 技能卡（你剛調的）
  const SP_TITLE  = 4;  // 標題→第一位的距離
  const SPACER    = 4;  // 成員之間距
  const MEMBERS   = 6;

  // 內部內容總高（標題卡 + 間距 + 6*(名稱卡+技能卡) + 5*間距）
  const innerH =
    (2 + TITLE_H) + SP_TITLE +
    (MEMBERS * (NAME_H + SKILL_H)) +
    ((MEMBERS - 1) * SPACER);

  // 外框 = 頂部色條 + 內邊距 + 內容 + 內邊距 + 微小 buffer
  return HEAD_H + INNER_PAD + innerH + INNER_PAD + 4;
}


function sortTeamsByPriority(teamsArr) {
  const order = { "進攻": 1, "拆塔": 2, "機動": 3, "防守": 4 };
  return [...teamsArr].sort((a, b) => (order[a.team] || 99) - (order[b.team] || 99));
}

// ================== 3) 下載圖片（行內團隊無水平間距 & 外框自動包覆） ==================
function downloadThisWeekImage() {
  const data = getPanelData(thisWeekPanel);

  const tagOrder = ["一團","二團","三團","四團"];
  const grouped = tagOrder
    .map(tag => ({ tag, teams: data.filter(t => (t.tag || "一團") === tag) }))
    .filter(g => g.teams.length > 0)
    .map(g => ({ tag: g.tag, teams: sortTeamsByPriority(g.teams) }));

  const rowHeaderH = 25;   // 團號灰底高度
  const rowGapY    = 12;   // 列間距
  const sidePad    = 20;   // 畫布左右邊界
  const bottomPad  = 12;  // 畫布底部留白（新增）
  const topPad     = 28;   // 標題上方留白
  const titleH     = 15;   // 標題高度

  // 先量每一列每個團的 w/h，取得列寬與列高（取該列最大團高）
  const rowMeasures = grouped.map(group => {
    const items = group.teams.map(team => ({
      team,
      w: getTeamCanvasWidth(team),
      h: getTeamCanvasHeight(team)
    }));
    const rowW = items.reduce((s, it) => s + it.w, 0);
    const rowH = Math.max(...items.map(it => it.h));
    return { tag: group.tag, items, rowW, rowH };
  });

  const canvasWidth  = Math.max(...rowMeasures.map(r => r.rowW + sidePad * 2), 420);
  const contentTotalH = rowMeasures.reduce((s, r) => s + (rowHeaderH + r.rowH), 0) + (rowMeasures.length - 1) * rowGapY;
  const canvasHeight = topPad + titleH + contentTotalH + sidePad;

  const SCALE = 3;
  const canvas = document.createElement("canvas");
  canvas.width = canvasWidth * SCALE;
  canvas.height = canvasHeight * SCALE;
  const ctx = canvas.getContext("2d");
  ctx.scale(SCALE, SCALE);

  // 背景與標題
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(0, 0, canvasWidth, canvasHeight);
  ctx.fillStyle = "#0f172a";
  ctx.font = "bold 18px system-ui";
  ctx.fillText("本週名單", sidePad, topPad);

  // 逐列繪製
  let currentY = topPad + titleH;
  rowMeasures.forEach(row => {
    // 團號灰底（寬度 = 該列所有團的總寬）
    const headerX = sidePad, headerW = row.rowW, headerH = rowHeaderH;
    ctx.fillStyle = "#B4BBC8";
    fillRoundRectCorners(ctx, headerX, currentY, headerW, headerH, 8, { tl:true, tr:true, br:false, bl:false });

    // 團號文字
    ctx.fillStyle = "#0f172a";
    ctx.font = "bold 14px system-ui";
    const tagTextW = ctx.measureText(row.tag).width;
    ctx.fillText(row.tag, headerX + (headerW - tagTextW) / 2, currentY + headerH / 2 + 5);

    // 同行團隊緊貼排列（每個團用各自的 h）
    let x = sidePad;
    const teamTopY = currentY + headerH;
    // 同一個「團號」（一團 / 二團 / 三團）裡的小隊要連號
let squadOffset = 1;  // 這一列從第1小隊開始

row.items.forEach(item => {
  const team = item.team;
  const squadCount = (team.squads && team.squads.length) ? team.squads.length : 0;

  // 把目前的起始小隊編號丟給這個團
  drawTeamBlockImage(ctx, team, x, teamTopY, item.w, item.h, squadOffset);

  // 下一個團的小隊編號接續往下排
  squadOffset += squadCount;

  x += item.w;
});


    currentY += headerH + row.rowH + rowGapY;
  });

  // 下載
  const link = document.createElement("a");
  link.download = "this-week.png";
  link.href = canvas.toDataURL("image/png");
  link.click();
}

// ================== 4) 單一卡片繪製（名稱卡＋技能卡分離，皆用 crisp 邊線） ==================
function drawTeamBlockImage(ctx, team, x, y, w, h, startIndex) {
  // 外框白卡片（四角圓）
  ctx.fillStyle = "#ffffff";
  fillRoundRectCorners(ctx, x, y, w, h, 12, {tl:true,tr:true,br:true,bl:true});
  strokeRoundedCrisp(ctx, x, y, w, h, 12, {tl:true,tr:true,br:true,bl:true}, "#B4BBC8");

  // 頂部團隊色條（無圓角）
  const headColor = teamColorByName(team.team);
  const HEAD_H = 30;
  ctx.fillStyle = headColor;
  ctx.fillRect(x, y, w, HEAD_H);

  // 團隊名稱
  ctx.fillStyle = "#ffffff";
  ctx.font = "bold 15px system-ui";
  const textW = ctx.measureText(team.team).width;
  ctx.fillText(team.team, x + (w - textW) / 2, y + Math.round(HEAD_H * 0.7));

  // 內部尺寸
  const INNER_PAD = 8;
  const gap = 4;
  const squads = team.squads || [];
  const squadCount = Math.max(1, (squads.length || 6));
  const availW = w - INNER_PAD * 2 - gap * (squadCount - 1);
  const squadW  = availW / squadCount;
  const availH  = h - HEAD_H - INNER_PAD * 2;

  // 高度配置（可自適應）
  let TITLE_H  = 28; // 小隊標題（四角圓獨立卡）
  let NAME_H   = 22; // 名稱卡高度（上半圓角）
  let SKILL_H  = 22; // 技能卡高度（下半圓角）
  let SP_TITLE = 4;       // 標題與第一位之間的距離
  let SPACER   = 4;       // 成員與成員之間距

  const totalNeed = TITLE_H + SP_TITLE + 6*(TITLE_H * 2) + 5*SPACER;
  if (totalNeed > availH) {
    const s = availH / totalNeed;
    TITLE_H  = Math.max(22, Math.floor(TITLE_H * s));
    NAME_H   = 22;
    SKILL_H  = 22;
  }

  for (let i = 0; i < squadCount; i++) {
    const sx = x + INNER_PAD + i * (squadW + gap);
    const sy = y + HEAD_H + INNER_PAD;

    // ① 小隊標題（四角圓，獨立卡）
const titleX = sx + 2, titleY = sy + 2, titleW = squadW - 4;
ctx.fillStyle = "#D6DDF0";
fillRoundRectCorners(ctx, titleX, titleY, titleW, TITLE_H, 8, {tl:true,tr:true,br:true,bl:true});
strokeRoundedCrisp(ctx, titleX, titleY, titleW, TITLE_H, 8, {tl:true,tr:true,br:true,bl:true}, "#B4BBC8");

// 小隊標題文字（水平置中）
ctx.fillStyle = "#0f172a";
ctx.font = "bold 13px system-ui";
const squadTitle = `第${startIndex + i}小隊`;
const textW = ctx.measureText(squadTitle).width;
ctx.fillText(squadTitle, titleX + (titleW - textW) / 2, titleY + Math.round(TITLE_H * 0.7));


    // 標題與第一位成員之間的空隙（避免殘線）
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(sx - 1, titleY + TITLE_H, squadW + 2, SP_TITLE);

    // ② 成員列（名稱卡＋技能卡分離）
    const squad = squads[i];
    let rowY = titleY + TITLE_H + SP_TITLE;

    for (let m = 0; m < 6; m++) {
      const nameBoxX = sx + 2;
      const nameBoxY = rowY;
      const nameBoxW = squadW - 4;
      const mem = (squad && squad.members[m]) ? squad.members[m] : null;

      // 名稱卡（上半圓角，獨立卡）
      ctx.fillStyle = "#ffffff";
      fillRoundRectCorners(ctx, nameBoxX, nameBoxY, nameBoxW, NAME_H, 6, { tl:true, tr:true, br:false, bl:false });
      strokeRoundedCrisp(ctx, nameBoxX, nameBoxY, nameBoxW, NAME_H, 6, { tl:true, tr:true, br:false, bl:false }, "#D8E2F2");

      // 左側職業色條 + 名稱文字
if (mem && mem.name) {
  const jobColor =
    mem.job && roleColors[mem.job]
      ? darkenHex(roleColors[mem.job], 0.25)
      : "#0f172a";

  // 左側職業色條（上圓下直）
  ctx.fillStyle = jobColor;
  ctx.beginPath();
  ctx.moveTo(nameBoxX, nameBoxY + 2); // 稍微下移一點，避免角太尖
  ctx.quadraticCurveTo(nameBoxX, nameBoxY, nameBoxX + 2, nameBoxY); // 左上圓角半徑 2
  ctx.lineTo(nameBoxX + 5, nameBoxY); // 上邊
  ctx.lineTo(nameBoxX + 5, nameBoxY + NAME_H); // 右邊
  ctx.lineTo(nameBoxX, nameBoxY + NAME_H); // 左下直角
  ctx.closePath();
  ctx.fill();

 // 名稱文字（自動縮放 + 柔厚平衡版）
ctx.fillStyle = jobColor;
let fontSize = 13;
ctx.font = `bold ${fontSize}px system-ui`;
let textWidth = ctx.measureText(mem.name).width;

// 若文字超出卡片寬度（扣掉左右邊距）
const maxWidth = nameBoxW - 12;
while (textWidth > maxWidth && fontSize > 10) {
  fontSize -= 0.5;
  ctx.font = `bold ${fontSize}px system-ui`;
  textWidth = ctx.measureText(mem.name).width;
}

// 模擬加粗：輕量雙層 shadow 疊描邊（柔厚不糊）
ctx.shadowColor = jobColor;
ctx.shadowBlur = 0;
ctx.shadowOffsetX = 0.6;  // ← 水平陰影略增
ctx.shadowOffsetY = 0.6;  // ← 垂直陰影略增
ctx.fillText(mem.name, nameBoxX + 9.5, nameBoxY + Math.round(NAME_H * 0.72));

// 反向再疊一次，讓筆畫厚度更均勻
ctx.shadowOffsetX = -0.4;
ctx.shadowOffsetY = -0.4;
ctx.fillText(mem.name, nameBoxX + 9.5, nameBoxY + Math.round(NAME_H * 0.72));

// 最上層主字：銳利乾淨收邊
ctx.shadowColor = "transparent";
ctx.fillText(mem.name, nameBoxX + 9.5, nameBoxY + Math.round(NAME_H * 0.72));



}


      rowY += NAME_H; // 接著畫技能卡

      // 技能卡（下半圓角，獨立卡）
      const skillBoxX = sx + 2;
      const skillBoxY = rowY;
      const skillBoxW = squadW - 4;
      const hasSkill = !!(mem && mem.skill && mem.skill.trim());

      ctx.fillStyle = hasSkill ? "#FFFFDB" : "#ffffff";
      fillRoundRectCorners(ctx, skillBoxX, skillBoxY, skillBoxW, SKILL_H, 6, { tl:false, tr:false, br:true, bl:true });
      strokeRoundedCrisp(ctx, skillBoxX, skillBoxY, skillBoxW, SKILL_H, 6, { tl:false, tr:false, br:true, bl:true }, "#D8E2F2");

      if (hasSkill) {
        ctx.fillStyle = "#0f172a";
        ctx.font = "bold 12px system-ui";
        ctx.fillText(mem.skill, skillBoxX + 5, skillBoxY + Math.round(SKILL_H * 0.71));
      }
      rowY += SKILL_H;
      // 成員之間的間距
      if (m !== 5) {
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(sx - 1, rowY, squadW + 2, SPACER);
        rowY += SPACER;
      }
    }
  }
}
// 以上這段 V14.7 完整下載圖片功能（名稱/技能兩張獨立卡）




/*V17.2 改成左鍵切換狀態 */
function onNameCellClick(e, input) {
  if (!input) return;
  const isThisWeekName =
    input.dataset.side === "this" && input.dataset.role === "name";
  const hasValue = (input.value || "").trim() !== "";
  // 本週名單 + 有名字：左鍵直接切換出席狀態
  if (isThisWeekName && hasValue) {
    if (e) {
      e.preventDefault();
      e.stopPropagation();
    }
    cycleCellStatus(input);  // present / late / unsure / absent 輪流
    return;
  }
  // 其他情況（或是空白格）維持原本：點空格才開搜尋
  maybeOpenMemberPicker(e, input);
}

/* V15 修正本週成員點擊問題 */
function maybeOpenMemberPicker(e, input) {
  // 現在只有本週欄位，直接依照「是否只讀 / 是否有值」決定行為
  if (input.readOnly) return;
  const hasValue = (input.value || "").trim() !== "";
  // 先擋掉瀏覽器預設行為（避免又開鍵盤）
  if (e) {
    e.preventDefault();
    e.stopPropagation();
  }
  // 已經有名字的格子：什麼都不做，只是當「點不到」
  if (hasValue) {
    input.blur();  // 保險再收一次游標
    return;
  }
  // 空白格子：開成員搜尋浮層
  input.blur();    // 確保不留下游標
  openMemberPicker(input);
}



  /* V14.9：搜尋框貼齊欄位下緣，左右依規則自動對齊 */
function openMemberPicker(input){
  pickerTargetInput = input;
  const rect = input.getBoundingClientRect();
  // 以所在的 .panel 為邊界，沒找到就用本週名單
  const panel = input.closest(".panel") || thisWeekPanel;
  const panelRect = panel.getBoundingClientRect();
  const pickerWidth = 260; // 搜尋浮層寬度
  // ① 預設：搜尋框「左邊」 = 欄位左邊
  //    → 最左列的小隊會齊左對齊成員
  let left = rect.left + window.scrollX;
  // ② 限制在 panel 內：超出才被「擠回來」
  //    → 最右列會齊右，其餘中間只在超出時微調
  const minLeft = panelRect.left + window.scrollX + 4;
  const maxLeft = panelRect.right + window.scrollX - pickerWidth - 4;
  if (left < minLeft) left = minLeft;
  if (left > maxLeft) left = maxLeft;
  // ③ 垂直位置：直接貼在欄位底部，**不要空隙**
  memberPicker.style.left = left + "px";
  memberPicker.style.top  = (rect.bottom + window.scrollY) + "px";
  memberPicker.style.display = "block";
  pickerSearch.value = "";
  renderPickerList(allMembers);
  pickerSearch.focus();
}


    function renderPickerList(list){
      pickerList.innerHTML = "";
      list.forEach(m=>{
        const item = document.createElement("div");
        item.className = "picker-item";
        item.textContent = m.name + (m.job? " ("+m.job+")": "");
        item.onclick = ()=>selectMemberFromPicker(m);
        pickerList.appendChild(item);
      });
    }
    function filterPickerList(){
      const kw = pickerSearch.value.trim();
      const list = allMembers.filter(m=>!kw || m.name.includes(kw) || (m.skill && m.skill.includes(kw)));
      renderPickerList(list);
    }


    /*V15.3替補列空白搜尋*/
    function selectMemberFromPicker(m){
      // ★ 1. 若是「幫眾＋」模式：直接加到幫眾欄位，完全不碰 pickerTargetInput
  if (window.guildAddMode) {
    window.guildAddMode = false;
    addGuildTag(
      guildBattleBox,
      { name: m.name, job: m.job || getJobByName(m.name) || "" },
      { bypassRules: false }
    );
    closeMemberPicker();
    saveState();
    updateGuildBattleAndWeekComparison();
    updateSubStatusByThisWeek();
    return;
  }

  // V18.3★ 2. 一般情況：原本的流程（本週名單 or 替補）維持不動
  if (!pickerTargetInput) return;
  // ① 本週名單欄位：維持原本「移位」邏輯 → 清掉其他同名
  if (pickerTargetInput.matches('#thisWeek input[data-role="name"]')) {
    // ✔ 本週名單：用 clearDuplicateInPanel，順便顯示「從哪一團第幾小隊移過來」
    clearDuplicateInPanel(thisWeekPanel, m.name, pickerTargetInput);
  // ② 替補欄位：視為「複製」，不要動到本週既有位置
  } else if (pickerTargetInput.matches('#subsList .sub-name')) {
    // ⭐ 這裡刻意什麼都不做
    // 不呼叫 clearDuplicateInPanel、不清除 thisWeekPanel 裡的任何格子
    // 讓同一個人可以同時出現在「本週」和「替補」
  // ③ 其他地方（如果未來有新增別的輸入欄位）
  } else {
    // 維持原本：只清掉本週名單裡的重複名字
    thisWeekPanel.querySelectorAll("input[data-role='name']").forEach(inp => {
      if (inp.value.trim() === m.name) {
        clearInputAndSkill(inp);
      }
    });
  }


  pickerTargetInput.value = m.name;
  applyJobColor(pickerTargetInput, m.job);
  pickerTargetInput.dataset.dirty = "1";
  fitNameFont(pickerTargetInput);
  // ⭐ 區分：本週欄位 vs 替補欄位
  if (pickerTargetInput.matches('#thisWeek input[data-role="name"]')) {
    // 本週：維持原本 skillRow 的寫法
    const skillRow = pickerTargetInput.parentElement.nextElementSibling;
    if (skillRow && skillRow.querySelector("input[data-role='skill']")) {
      setSkillInputValue(
        skillRow.querySelector("input[data-role='skill']"),
        m.skill || ""
      );
    }
    // 🔹 V18.1：搜尋選進「本週名單」時，一律預設為「未上線」
    setCellStatus(pickerTargetInput, "absent");
  } else if (pickerTargetInput.matches('#subsList .sub-name')) {
    // 替補：在同一列找 .sub-skill
    const row = pickerTargetInput.closest('.substitute-row');
    if (row) {
      const subSkill = row.querySelector('.sub-skill');
      if (subSkill) {
        subSkill.value = m.skill || "";
      }
    }
  }
  saveState();
// ★ 若這次選的是「本週名單」的成員欄位 → 重新比對
if (pickerTargetInput &&
    pickerTargetInput.matches('#thisWeek input[data-role="name"]')) {
  updateGuildBattleAndWeekComparison();
}
// V18.3 新增：無論選的是哪裡，只要關掉 picker 前都重新更新替補狀態
updateSubStatusByThisWeek();

closeMemberPicker();

}

  
    
    function closeMemberPicker(){ memberPicker.style.display = "none"; pickerTargetInput = null; }
    document.addEventListener("click", function(e){ if (!memberPicker.contains(e.target) && e.target !== pickerTargetInput) { closeMemberPicker(); } });

    function updateSkillColor(cell) {
      const skill = cell.querySelector(".skill");
      if (!skill) return;
      const text = (skill.textContent || "").trim();
      if (text) skill.style.background = "#fef9c3";
      else skill.style.background = "transparent";
    }

/* V21：真正拆分後的 loadState（核心資料 + 四團分開） */
async function loadState() {
  showLoadingMask();

  let localState = null;
  let cloudState = null;
  let cloudSuccess = false;
  // ① 先讀 localStorage（離線備份）
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (raw) {
      localState = JSON.parse(raw);
    }
  } catch (e) {
    console.warn("讀取 localStorage 失敗", e);
  }
  // ② 再讀雲端主文件：guildBattleStates/default-room（只拿核心資料）
  try {
    if (typeof stateDocRef !== "undefined" && stateDocRef) {
      const docSnap = await stateDocRef.get();
      if (docSnap.exists) {
        const data = docSnap.data() || {};
        if (data.payload) {
          cloudState = data.payload; // ★ 不再使用 payload.thisWeek
          cloudSuccess = true;
        }
        if (data.updatedAt) {
          try {
            lastKnownUpdatedAt = data.updatedAt.toMillis
              ? data.updatedAt.toMillis()
              : data.updatedAt;
          } catch (e) {
            lastKnownUpdatedAt = Date.now();
          }
        }
      }
    }
  } catch (err) {
    console.warn("雲端讀取失敗或逾時（Firebase）", err);
  }
  // ③ 用 cloudState 的「核心資料」搭配 localState 的 thisWeek，先組一份暫時的狀態
  const baseAllMembers =
    (cloudState && cloudState.allMembers) ||
    (localState && localState.allMembers) ||
    allMembers;
  const baseSubs =
    (cloudState && cloudState.subs) ||
    (localState && localState.subs) ||
    getSubsData();
  const baseGuildPositions =
    (cloudState && cloudState.guildPositions) ||
    (localState && localState.guildPositions) ||
    getGuildPositionsData();
  const baseRecentMarks =
    (cloudState && cloudState.recentMarks) ||
    (localState && localState.recentMarks) ||
    collectRecentMarks();
  const baseThisWeek =
    (localState && localState.thisWeek) || getPanelData(thisWeekPanel);
  let finalState = {
    allMembers: baseAllMembers,
    subs: baseSubs,
    guildPositions: baseGuildPositions,
    recentMarks: baseRecentMarks,
    thisWeek: baseThisWeek // 先放一份，等一下用四團資料完全覆蓋
  };
  // ④ 從四個 team 文件讀取真正的 thisWeek（offense / tower / mobile / defence）
  try {
    const teamNames = ["進攻", "拆塔", "機動", "防守"];
    const byTeam = {};
    // 先準備四個空殼（避免沒資料整團消失）
    teamNames.forEach((name) => {
      byTeam[name] = {
        team: name,
        tag: name === "進攻" || name === "拆塔" ? "一團" : "二團",
        squads: []
      };
    });
    // 從 Firestore 讀取 /guildBattleStates/default-room/teams/{offense,tower,mobile,defence}
    for (const name of teamNames) {
      const ref = teamDocRefs[name];
      if (!ref) continue;
      const snap = await ref.get();
      if (snap.exists) {
        const data = snap.data() || {};
        if (Array.isArray(data.squads)) {
          byTeam[name].squads = data.squads;
        }
        if (data.tag) {
          byTeam[name].tag = data.tag;
        }
      }
    }
    // 用四團資料完全覆蓋 thisWeek（不再理 payload.thisWeek）
    finalState.thisWeek = teamNames.map((name) => byTeam[name]);
    // 同時初始化「已同步基準」，給之後 autosave 用
    try {
      const teamBaseline = {};
      (finalState.thisWeek || []).forEach((team) => {
        if (team && team.team) {
          teamBaseline[team.team] = Array.isArray(team.squads)
            ? team.squads
            : [];
        }
      });
      lastSavedTeamsData = teamBaseline;
      lastSavedAllMembersStr = JSON.stringify(finalState.allMembers || []);
    } catch (e) {
      console.warn("初始化 lastSavedTeamsData 失敗", e);
    }
  } catch (e) {
    console.warn("讀取分團 thisWeek 失敗，暫時使用本機 thisWeek", e);
  }
  // ⑤ 套用到畫面
  applyStateToPage(finalState, !cloudSuccess);
  // ⑥ 更新 localStorage，讓下次開頁有最新初始狀態
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(finalState));
  } catch (e) {
    console.warn("寫入 localStorage 失敗", e);
  }
  hideLoadingMask();
  if (!cloudSuccess) {
    showWeekToast("⚠️ 無法取得雲端資料（Firebase），已使用上次離線版本");
  }
  // ⑦ 啟動版本監聽 + 各團即時監聽
  /*暫時不監聽startVersionWatcher();*/
  startTeamWatchers();
  // ⑧ 一開頁面補一次比對 & placeholder
  updateGuildBattleAndWeekComparison();
  maintainGuildBattlePlaceholders();
}






    // V14.9根據名字長度自動縮放字體大小（只管本週名單 + 替補名字）
function fitNameFont(input) {
  if (!input) return;
  const len = (input.value || "").length;
  // 基本邏輯：7 字以內維持原來，越長就越小一點
  let size = 13;        // 預設（對應你手機版 CSS 的 13px）
  if (len > 7 && len <= 9)  size = 12;
  else if (len > 9 && len <= 11) size = 11;
  else if (len > 11)         size = 10;
  input.style.fontSize = size + "px";
}
// 一次掃描整個畫面上的名字欄位，全部套一次
function refreshAllNameFonts() {
  document
    .querySelectorAll('#thisWeek input[data-role="name"], #subsList .sub-name')
    .forEach(fitNameFont);
}


    loadState();
    // 面板與替補區：任何 input/change 皆視為編輯
    ["input","change"].forEach(evt=>{
    thisWeekPanel.addEventListener(evt, suppressOutlinesOnEdit, true);
    subsList.addEventListener(evt, suppressOutlinesOnEdit, true);
    });
    // 拖曳開始也視為編輯（即使尚未放下）
    document.addEventListener("dragstart", suppressOutlinesOnEdit, true);
    // 使用者在「本週名單 / 替補」輸入名字時，立即重新算字體大小
    
    attachIOSZoomFix();

 // V15.1修正版✅ 只要「本週名單」或「替補名單」的成員欄位被 focus，就立刻 blur 掉
document.addEventListener("focusin", function (e) {
  const t = e.target;
  if (!t || !t.matches) return;

  // 本週名單名字欄位 ＋ 替補列名字欄位 都套用
  if (t.matches('#thisWeek input[data-role="name"], #subsList .sub-name')) {
    // iOS/Safari 有時候要晚一拍 blur，所以用 setTimeout 0
    setTimeout(() => {
      if (document.activeElement === t) {
        t.blur();        // 把游標收掉，不讓鍵盤跳出
      }
    }, 0);
  }
});

    
    // ✅ iOS：避免本週 / 替補名字欄位被點擊時整頁 ZOOM IN
function attachIOSZoomFix() {
  if (!isIOS) return; // 只有 iPhone / iPad 才啟動
  // focusin：只有「空的欄位」才套上 ios-zoom-fix，避免已填好的人名放大
  document.addEventListener("focusin", function (e) {
    const t = e.target;
    if (!t || !t.matches) return;
    // 只針對「本週名單的名字欄位」＋「替補名字欄位」
    if (t.matches('#thisWeek input[data-role="name"], #subsList .substitute-row .sub-name')) {
      // ✅ 若欄位已有文字，就不要放大字體
      if ((t.value || "").trim() !== "") return;
      t.classList.add("ios-zoom-fix");
    }
  });
  // focusout：離開輸入框時，把 class 拿掉，交回給 fitNameFont 控制大小
  document.addEventListener("focusout", function (e) {
    const t = e.target;
    if (!t || !t.classList) return;
    if (t.classList.contains("ios-zoom-fix")) {
      t.classList.remove("ios-zoom-fix");
    }
  });
}


// ─────────────────────
// V18 手機版幫會職位 bottom sheet
// ─────────────────────
let guildDrawerOpen = false;
function openGuildDrawer() {
  const panel = document.getElementById('guildPositions');
  if (!panel) return;
  panel.classList.add('is-open');
  guildDrawerOpen = true;
  // 建立半透明背景
  let backdrop = document.querySelector('.guild-backdrop');
  if (!backdrop) {
    backdrop = document.createElement('div');
    backdrop.className = 'guild-backdrop';
    backdrop.addEventListener('click', closeGuildDrawer);
    document.body.appendChild(backdrop);
  }
}
function closeGuildDrawer() {
  const panel = document.getElementById('guildPositions');
  if (!panel) return;
  panel.classList.remove('is-open');
  guildDrawerOpen = false;
  const backdrop = document.querySelector('.guild-backdrop');
  if (backdrop) backdrop.remove();
  // 把暫時加上的位移清回去
  panel.style.transform = '';
}
/* 讓上方灰條可以「往下拖曳」收合（tap 不關，只辨識拖曳） */
function setupGuildDrawerDrag() {
  const panel  = document.getElementById('guildPositions');
  if (!panel) return;

  const handle = panel.querySelector('.guild-drawer-header');
  if (!handle) return;
  let startY = 0;
  let currentY = 0;
  let dragging = false;
  function startDrag(e) {
    // 只在手機寬度啟用
    if (window.innerWidth > 900) return;
    dragging = true;
    startY = (e.touches ? e.touches[0].clientY : e.clientY);
    currentY = 0;
    panel.style.transition = 'none';
    window.addEventListener('mousemove', moveDrag);
    window.addEventListener('touchmove', moveDrag, { passive: false });
    window.addEventListener('mouseup', endDrag);
    window.addEventListener('touchend', endDrag);
  }
  function moveDrag(e) {
    if (!dragging) return;
    const y = (e.touches ? e.touches[0].clientY : e.clientY);
    currentY = y - startY;
    if (currentY < 0) currentY = 0;
    panel.style.transform = `translateY(${currentY}px)`;
    if (e.cancelable) e.preventDefault();
  }
  function endDrag() {
    if (!dragging) return;
    dragging = false;
    window.removeEventListener('mousemove', moveDrag);
    window.removeEventListener('touchmove', moveDrag);
    window.removeEventListener('mouseup', endDrag);
    window.removeEventListener('touchend', endDrag);
    panel.style.transition = 'transform .25s ease-out';
    // 往下拉超過 80px 就關閉；否則彈回去
    if (currentY > 80) {
      closeGuildDrawer();
    } else {
      panel.style.transform = 'translateY(0)';
    }
  }
  handle.addEventListener('mousedown', startDrag);
  handle.addEventListener('touchstart', startDrag);
}
// DOM 載入完就把拖曳關閉初始化
document.addEventListener('DOMContentLoaded', setupGuildDrawerDrag);
  </script>
</body>
</html>
