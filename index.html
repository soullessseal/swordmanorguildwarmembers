  <!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>å¹«æˆ°åå–®æ¯”å°å·¥å…· v14.7</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --bg: #0f172a;
      --card: #ffffff;
      --line: #e2e8f0;
      --green: #dcfce7;
      --red: #fee2e2;
      --text: #0f172a;
      --radius: 0.75rem;
    }
    body {
      background: var(--bg);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 1.25rem;
      font-size: 16px;
    }
    h1 { color: #fff; margin: 0 0 .75rem; }
    .layout { display: grid; grid-template-columns: 0.65fr 1.45fr 1.45fr 0.65fr; gap: 1rem; align-items: flex-start; }
    .panel { background: var(--card); border-radius: var(--radius); padding: 1rem; border: 1px solid rgba(15, 23, 42, 0.05); box-shadow: 0 10px 30px rgba(0,0,0,.04); }
    #allMembersPanel { position: sticky; top: 1rem; z-index: 5; }
    .right-sticky-wrap { position: sticky; top: 1rem; z-index: 6; display: flex; flex-direction: column; gap: .6rem; }
    .right-actions-bar { display: flex; gap: .4rem; justify-content: flex-end; }
    .float-btn { background: #0ea5e9; border: none; color: #fff; padding: 0.35rem 0.75rem; border-radius: 999px; font-weight: 600; font-size: 0.78rem; cursor: pointer; white-space: nowrap; }
    .float-btn.secondary { background: #1f2937; }
    .float-btn.danger { background: #ef4444; }
    .member-search { width: 100%; padding: 0.4rem 0.5rem; border: 1px solid #cbd5e1; border-radius: 0.4rem; margin-bottom: 0.5rem; font-size: 0.85rem; box-sizing: border-box; }
    .role-tabs { display: flex; flex-wrap: wrap; gap: .35rem; margin-bottom: .5rem; }
    .role-tab { padding: 0.25rem 0.6rem; border-radius: 999px; color: #0f172a; font-size: 0.73rem; cursor: pointer; border: 1px solid transparent; user-select: none; white-space: nowrap; }
    .role-tab.active { border: 1px solid #0f172a44; }
    .member-list { border: 1px solid #e2e8f0; border-radius: 0.5rem; padding: 0.4rem; background: #f8fafc; }
    .member-item { display: flex; justify-content: space-between; gap: .35rem; align-items: center; background: #fff; border-radius: .35rem; padding: .3rem .35rem; margin-bottom: .3rem; border: 1px solid #e2e8f0; cursor: grab; }
    .member-left { flex: 1 1 auto; min-width: 0; }
    .member-name { font-weight: 700; font-size: .9rem; }
    .member-skill { font-size: .7rem; opacity:.7; }
    .member-actions { display:flex; gap:.25rem; }
    .member-actions button { border:none; background:#e2e8f0; font-size:.65rem; border-radius:.35rem; padding:.25rem .45rem; cursor:pointer; }
    .pagination { display:flex; justify-content:center; gap:.35rem; margin-top:.4rem; }
    .pagination button { border:1px solid #cbd5e1; background:#fff; border-radius:.35rem; font-size:.65rem; padding:.25rem .45rem; cursor:pointer; }
    .pagination select { font-size:.7rem; }
    .add-member-form { margin-top: .35rem; display: none; flex-direction: column; gap: 0.3rem; width: 100%; }
    .add-member-form input, .add-member-form select { padding: 0.35rem 0.4rem; border: 1px solid #cbd5e1; border-radius: 0.4rem; font-size: 0.78rem; width: 100%; box-sizing: border-box; }

    .team-block { border: 1px solid var(--line); border-radius: 0.5rem; margin-bottom: 1rem; overflow: hidden; }
    .team-head { color: #fff; padding: 0.4rem 0.6rem; display: flex; justify-content: space-between; align-items: center; font-size: 0.9rem; gap: .5rem; }
    .team-head-left { display:flex; align-items:center; gap:.4rem; }
    .team-tag-select { font-size: .78rem; font-weight: 700; border-radius: .35rem; border: none; padding: .2rem .45rem; background: rgba(255,255,255,0.95); color: #0f172a; line-height: 1.2; cursor: pointer; }
    .team-tag-select option { font-size: .78rem; font-weight: 600; color: #0f172a; }
    .team-tag-label { background: rgba(255,255,255,0.95); color: #0f172a; font-size: .78rem; font-weight: 700; border-radius: .35rem; padding: .2rem .55rem; }
    .head-add-btn { background: rgba(255,255,255,0.12); border: 1px solid rgba(255,255,255,0.25); color: #fff; font-size: .65rem; border-radius: .35rem; padding: .2rem .45rem; cursor: pointer; }
    .head-add-btn.disabled { opacity:.35; cursor:not-allowed; }

    .squads { display: flex; flex-wrap: nowrap; border-top: 1px solid var(--line); width: 100%; }
    .squad { border-left: 1px solid var(--line); padding: 0.4rem 0.4rem 0.75rem; position: relative; flex: 1 1 auto; min-width: 0; }
    .squad:first-child { border-left: none; }
    .squad-title { background: #f8fafc; text-align: center; font-weight: 700; padding: 0.3rem; border-radius: 0.25rem; margin-bottom: 0.4rem; border: 1px solid #e2e8f0; font-size: 0.78rem; }
    .squad-del-btn { position: absolute; top: 6px; right: 6px; width: 22px; height: 22px; border: none; border-radius: 999px; background: #ef4444; color: #fff; font-size: 14px; line-height: 22px; text-align: center; cursor: pointer; padding: 0; }
    @media (max-width: 600px) { .squad-del-btn { top: 4px; right: 4px; width: 20px; height: 20px; line-height: 20px; font-size: 13px; } }

    .team-dots { display: none; }

    @media (max-width: 900px) {
      #thisWeek, #lastWeek { overflow-x: visible; white-space: normal; }
      #thisWeek .teams-wrap, #lastWeek .teams-wrap { position: relative; width: 100%; }
      #thisWeek .team-block, #lastWeek .team-block { width: 100%; display: none; }
      #thisWeek .team-block.active, #lastWeek .team-block.active { display: block; }
      .team-dots { display: flex; gap: 6px; justify-content: center; margin-top: .5rem; }
      .team-dot { width: 8px; height: 8px; border-radius: 999px; background: #cbd5e1; border: none; padding: 0; }
      .team-dot.active { background: #0f172a; }
      .team-block .squads { overflow-x: visible; width: 100%; }
      .team-block .squad { min-width: 0; }
    }

    .member-row { display:flex; gap:.25rem; margin-bottom:.3rem; }
    .member-row input { width: 100%; font-size: 0.78rem; padding: 0.3rem 0.35rem; border: 1px solid #cbd5f5; border-radius: 0.25rem; box-sizing: border-box; font-weight: 700; }
    .readonly-skill { background:#e2e8f0; }
    .locked-input { background:#e2e8f0; }

    .highlight-new { background:#bbf7d0 !important; border:1px solid #166534 !important; color:#064e3b !important; }
    .highlight-missing { background:#fca5a5 !important; border:1px solid #b91c1c !important; color:#7f1d1d !important; }

    #subsList { display:flex; flex-direction:column; gap:.25rem; }
    .substitute-row { display: grid; grid-template-columns: 1fr 1fr auto; grid-template-rows: auto auto; gap: 0.25rem; align-items: center; border: 1px solid #e2e8f0; border-radius: 0.35rem; padding: 0.25rem; background: #f8fafc; }
    .substitute-row input { width: 100%; padding: 0.25rem 0.3rem; border-radius: 0.25rem; border: 1px solid #e2e8f0; font-size: 0.78rem; font-weight: 700; box-sizing: border-box; }
    .del-btn { background: #ef4444; color: #fff; border: none; border-radius: 0.35rem; padding: 0.22rem 0.45rem; font-size: 0.7rem; cursor: pointer; }
    .substitute-row span.sub-status { grid-column: 1 / span 3; font-size: 0.7rem; min-height: 1.2rem; }
    .drag-preview { position: fixed; pointer-events: none; z-index: 9999; padding: 0.2rem 0.5rem; background: #0f172a; color: #fff; font-size: 0.65rem; border-radius: 999px; }

    #thisWeek { position: relative; }
    #downloadBtn { position: absolute; top: 1rem; right: 1rem; background: #0f766e; }

    #loginModal { position: fixed; inset: 0; background: rgba(15,23,42,.5); display: none; align-items: center; justify-content: center; z-index: 99999; }
    #loginModal .modal-card { background: #fff; border-radius: .75rem; padding: 1.2rem 1.4rem; width: 280px; box-shadow: 0 20px 40px rgba(0,0,0,.12); }
    #loginModal h3 { margin: 0 0 .5rem; font-size: 1.05rem; }
    #loginModal input { width: 100%; margin-bottom: .5rem; padding: .35rem .4rem; border: 1px solid #cbd5e1; border-radius: .4rem; }

    .outline-dabai { outline: 2px solid #a855f7; outline-offset: 2px; }
    .outline-baoan { outline: 2px solid #ef4444; outline-offset: 2px; }
    .outline-stitch { outline: 2px solid #38bdf8; outline-offset: 2px; }

    #comparePanel h3 { margin-top: 0; }
    .compare-tags { display:flex; flex-wrap:wrap; gap:.35rem; }
    .compare-tag { background:#e2e8f0; border-radius:999px; padding:.2rem .6rem; font-size:.65rem; cursor:pointer; user-select:none; }
    .compare-tag.muted { background:#0f172a; color:#fff; opacity:.55; }

    #memberPicker { position: absolute; background: #fff; border: 1px solid #cbd5e1; border-radius: .5rem; box-shadow: 0 15px 30px rgba(15,23,42,.12); width: 220px; display: none; z-index: 9999; padding: .4rem; overflow: hidden; }
    #memberPicker input { width: 100%; margin-bottom: .35rem; padding: .3rem .4rem; border: 1px solid #cbd5e1; border-radius: .35rem; box-sizing: border-box; }
    #memberPicker .picker-list { max-height: 180px; overflow-y: auto; }
    #memberPicker .picker-item { padding: .25rem .2rem; border-radius: .35rem; cursor: pointer; font-size: .75rem; }
    #memberPicker .picker-item:hover { background: #e2e8f0; }

    @media (max-width: 1300px) {
      .layout { grid-template-columns: 1fr; }
      #allMembersPanel, .right-sticky-wrap { position: static; }
      #downloadBtn { position: absolute; top: 1rem; right: 1rem; margin-bottom: 0; }
    }

    .compare-tag.new-tag { background:#bbf7d0; border:1px solid #166534; color:#064e3b; }
    .compare-tag.missing-tag { background:#fca5a5; border:1px solid #b91c1c; color:#7f1d1d; }

    /* ğŸ”ºå¼·åŒ–å¾…è™•ç†æ¬„ä½ç´…ç¶ æ¨™ç±¤æ–‡å­—å¤§å°èˆ‡ç²—é«” */
    #compareTags .compare-tag.new-tag,
    #compareTags .compare-tag.missing-tag {
    font-size: 0.78rem;      /* åŸæœ¬ .65rem â†’ æ”¾å¤§ä¸€é» */
    font-weight: 700;      /* ç²—é«”åŠ å¼·è¾¨è­˜ */
    padding: 0.3rem 0.35rem;  /* è®“å­—æ”¾å¤§å¾Œä¸æœƒæ“  */
    }
    #stuckList .compare-tag.missing-tag {
    font-size: 0.78rem;
    font-weight: 700;
    padding: 0.3rem 0.35rem;
    }
    
    input.skill-has { background: #FFFFDB; color: #0f172a; font-weight: 600; }

    /* æ‰‹æ©Ÿæ¿åº•éƒ¨æŒ‰éˆ• */
    @media (max-width: 900px) {
      .right-actions-bar {
        position: fixed;
        bottom: 1rem;
        left: 1rem;
        right: 1rem;
        background: rgba(15, 23, 42, 0.95);
        padding: .4rem .4rem;
        display: flex;
        gap: .5rem;
        justify-content: space-between;
        z-index: 9999;
        border-radius: 1rem;
        height: 2.5rem;
        align-items: center;
      }
      .right-actions-bar .float-btn { flex: 1; padding: .4rem .6rem; font-size: .85rem; font-weight: 600; border-radius: .999rem; }
      body { padding-bottom: 5.2rem; }
      .right-sticky-wrap { position: static; }
    }

    .panel-title-row { display: flex; align-items: center; justify-content: space-between; gap: .5rem; margin-bottom: .3rem; }
    #downloadBtn { position: static; }
  </style>
</head>
<body>
  <h1>å¹«æˆ°åå–®æ¯”å°å·¥å…· v14.7</h1>

  <div class="layout">
    <!-- å·¦å´ï¼šå…¨éƒ¨æˆå“¡ -->
    <div class="panel" id="allMembersPanel">
      <h3>å…¨éƒ¨æˆå“¡åå–®</h3>
      <input id="memberSearch" class="member-search" placeholder="æœå°‹æˆå“¡åæˆ–æŠ€èƒ½..." oninput="renderMemberList(); saveState();" />
      <div class="role-tabs" id="roleTabs"></div>
      <div class="member-list" id="memberList"></div>
      <div class="pagination">
        <button onclick="prevPage()">â—€</button>
        <select id="pageSelect" onchange="jumpPage(this.value)"></select>
        <button onclick="nextPage()">â–¶</button>
      </div>
      <div style="margin-top:.5rem;">
        <button class="float-btn secondary" style="background:#475569;" onclick="toggleAddMember()">ï¼‹ æ–°å¢æˆå“¡</button>
        <div class="add-member-form" id="addMemberForm">
          <input id="newName" placeholder="æˆå“¡åç¨±" />
          <select id="newJob">
            <option value="">é¸æ“‡è·æ¥­</option>
            <option value="ä¹éˆ">ä¹éˆ</option>
            <option value="éµè¡£">éµè¡£</option>
            <option value="ç´ å•">ç´ å•</option>
            <option value="é¾åŸ">é¾åŸ</option>
            <option value="ç¥ç›¸">ç¥ç›¸</option>
            <option value="ç¢å¤¢">ç¢å¤¢</option>
            <option value="è¡€æ²³">è¡€æ²³</option>
          </select>
          <input id="newSkill" placeholder="æˆå“¡æŠ€èƒ½ï¼ˆå¯ä¸å¡«ï¼‰" />
          <button class="float-btn" style="width:100%;text-align:center;" onclick="addMember()">ç¢ºèªæ–°å¢</button>
        </div>
      </div>
    </div>

    <!-- ä¸Šé€± -->
    <div class="panel" id="lastWeek">
      <div class="panel-title-row">
        <h3>ä¸Šé€±åå–®</h3>
      </div>
      <small style="font-size:.7rem;color:#64748b;">åªèƒ½é€éã€Œæœ¬é€±åå–®è¦†è“‹ä¸Šé€±ã€æ›´æ–°ï¼Œä¸å¯æ‰‹å‹•ç·¨è¼¯ã€‚</small>
    </div>

    <!-- æœ¬é€± -->
    <div class="panel" id="thisWeek">
      <div class="panel-title-row">
        <h3>æœ¬é€±åå–®</h3>
        <button id="downloadBtn" class="float-btn secondary" onclick="downloadThisWeekImage()">ä¸‹è¼‰åœ–ç‰‡</button>
      </div>
      <small style="font-size:.7rem;color:#64748b;">åŒå´äº’æ‹–ï¼›æ‹–åˆ°ç©ºç™½è¦–ç‚ºç§»é™¤ï¼›é‡è¤‡æˆå“¡ä»¥æ–°ä½ç½®ç‚ºä¸»ã€‚</small>
    </div>

    <!-- å³å´ -->
    <div class="right-sticky-wrap">
      <div class="right-actions-bar">
        <button class="float-btn danger" onclick="requestSave()">å„²å­˜</button>
        <button class="float-btn" onclick="compare()">æ¯”å°</button>
        <button class="float-btn secondary" onclick="copyThisToLast()">æœ¬é€±åå–®è¦†è“‹ä¸Šé€±</button>
        <button class="float-btn secondary" onclick="undoCopy()">é‚„åŸ</button>
      </div>

      <div class="panel" id="subs">
        <h3>æ›¿è£œåå–®</h3>
        <p style="font-size:0.7rem;margin-top:0;">å¯æ‹–é€²æœ¬é€±ï¼›æ‹–é€²å·²æœ‰æˆå“¡æ¬„ä½æœƒäº¤æ›ã€‚</p>
        <div id="subsList"></div>
        <div class="pagination" id="subsPager">
          <button onclick="subsPrev()">â—€</button>
          <select id="subsPageSelect" onchange="subsJump(this.value)"></select>
          <button onclick="subsNext()">â–¶</button>
        </div>
        <button class="float-btn secondary" style="margin-top:.5rem;" onclick="addSub()">æ–°å¢æ›¿è£œåˆ—</button>
      </div>

      <div class="panel" id="comparePanel">
  <h3>å¾…è™•ç†æˆå“¡</h3>
  <p style="font-size:0.7rem;margin-top:0;">é»ä¸€ä¸‹éš±è—/æ¢å¾©é‚£å€‹äººçš„ç´…ç¶ æ¨™ç¤º</p>
  <!-- æ“ä½œæŒ‰éˆ•å€ -->
  <div style="margin-bottom:.6rem;">
    <button class="float-btn secondary" 
      style="margin-top:.4rem; background:rgba(239,68,68,0.85); color:#fff; border:none; font-weight:600; transition:background 0.2s ease, box-shadow 0.2s ease;" 
      onclick="saveCompareIgnore()">
      ä¿å­˜è™•ç†
    </button>
  </div>
  <!-- å¾…è™•ç†åå–® -->
  <div id="compareTags" class="compare-tags" style="margin-top:.4rem;"></div>
  <hr style="margin:.6rem 0;border:none;border-top:1px dashed #cbd5e1;">
  <!-- æ›è·åå–® -->
  <h4 style="font-size:.8rem;margin:.3rem 0 .25rem;">æ›è·åå–®ï¼š</h4>
  <div id="stuckList" class="compare-tags"></div>
</div>

    </div>
  </div>

  <!-- æˆå“¡æœå°‹æµ®å±¤ -->
  <div id="memberPicker">
    <input id="pickerSearch" placeholder="æœå°‹æˆå“¡..." oninput="filterPickerList()" />
    <div class="picker-list" id="pickerList"></div>
  </div>

  <!-- ç™»å…¥ modal -->
  <div id="loginModal">
    <div class="modal-card">
      <h3>è«‹å…ˆç™»å…¥</h3>
      <input id="loginUser" placeholder="å¸³è™Ÿ" />
      <input id="loginPass" placeholder="å¯†ç¢¼" type="password" />
      <div style="display:flex;gap:.5rem;justify-content:flex-end;">
        <button class="float-btn secondary" onclick="closeLogin()">å–æ¶ˆ</button>
        <button class="float-btn" onclick="doLogin()">ç™»å…¥</button>
      </div>
      <p id="loginMsg" style="color:#b91c1c;font-size:.7rem;margin-top:.4rem;"></p>
    </div>
  </div>

  <script>
    const STORAGE_KEY = "guildCompareV12State";
    const LOGIN_STORAGE_KEY = "guildCompareLogin";
    const REMOTE_API = "https://script.google.com/macros/s/AKfycbxI39kkO1P02H-ozH3r8zD1m13ACuzcKY1db3f0wSssrooNeYLcNADntmvglirjz6Al/exec";
    const LOGIN_TTL = 60 * 60 * 1000;
    // è®“ã€Œæœ€è¿‘ä¿®æ”¹æ¡†ç·šã€åœ¨ç·¨è¼¯æœŸé–“æš«æ™‚éš±è—
    let outlinesSuppressed = false;
    
    function suppressOutlinesOnEdit(){
    if (!outlinesSuppressed) {
    outlinesSuppressed = true;
    clearAllOutlines(); // ç«‹åˆ»æŠŠç¾æœ‰æ¡†ç·šæ¸…æ‰
      }
    }
    
    let currentUser = null;
    let lastLoginTime = 0;

    const OUTLINE_CLASS = { dabai: "outline-dabai", baoan: "outline-baoan", stitch: "outline-stitch", unknown: "outline-dabai" };

    let lastKnownUpdatedAt = null;

    const teams = ["é€²æ”»","æ‹†å¡”","æ©Ÿå‹•","é˜²å®ˆ"];
    const roleColors = {
      "ä¹éˆ": "#d8b4fe","éµè¡£": "#fdba74","ç´ å•": "#f9a8d4","é¾åŸ": "#92d46d","ç¥ç›¸": "#3b82f6","ç¢å¤¢": "#7dd3fc","è¡€æ²³": "#f43f5e"
    };

    let allMembers = [
      {id:1, name: "å››å­£æ˜¥æ›‰å·", job: "ä¹éˆ", skill: "å·¦éˆå¤©æµ©æ„"},
      {id:2, name: "ç‹æˆ€é›ª", job: "ç´ å•", skill: "å¤ªæ¥µåœ–"},
      {id:3, name: "ç¿¼æ­Œ", job: "é¾åŸ", skill: "å¤ªæ¥µåœ–"},
      {id:4, name: "æœ¨å­ç¶­", job: "éµè¡£", skill: ""},
      {id:5, name: "çµ¦é›€å¿ƒè£¹", job: "ç¥ç›¸", skill: ""},
      {id:6, name: "ç–é¨", job: "è¡€æ²³", skill: ""},
      {id:7, name: "é˜¿å¦™", job: "ç´ å•", skill: ""},
      {id:8, name: "å°è‘‰é’", job: "ç¢å¤¢", skill: ""},
      {id:9, name: "ç ´é¢¨", job: "è¡€æ²³", skill: "çˆ†ç™¼"},
      {id:10, name: "é’ç‚", job: "é¾åŸ", skill: ""},
      {id:11, name: "ç…™é›¨", job: "ä¹éˆ", skill: ""}
    ];

    let nextMemberId = 12;
    let activeRoleFilter = "";
    let lastSnapshot = null;
    let memberPage = 1;
    const pageSize = 8;
    let subCounter = 0;

    const lastWeekPanel = document.getElementById("lastWeek");
    const thisWeekPanel = document.getElementById("thisWeek");
    const subsList = document.getElementById("subsList");
    const memberList = document.getElementById("memberList");
    const searchInput = document.getElementById("memberSearch");
    const roleTabs = document.getElementById("roleTabs");
    const compareTagsEl = document.getElementById("compareTags");

    const STORAGE_IGNORE_KEY = "guildCompareIgnore";
    const STORAGE_STUCK_KEY  = "guildStuckMembers";
    let persistentCompareIgnore = new Set();
    let currentMissingNotIgnored = [];

    let draggingPanelInput = null;
    let draggingPanelSide = null;
    let dragSuccess = false;
    let dragPreviewEl = null;

    const compareIgnore = new Set();

    let pickerTargetInput = null;
    const memberPicker = document.getElementById("memberPicker");
    const pickerList = document.getElementById("pickerList");
    const pickerSearch = document.getElementById("pickerSearch");

    function sameJSON(a,b){return JSON.stringify(a)===JSON.stringify(b);}

    function teamColorByName(name){
      if(name==="æ‹†å¡”") return "#7f1d1d";
      if(name==="æ©Ÿå‹•") return "#4c1d95";
      if(name==="é˜²å®ˆ") return "#1e3a8a";
      return "#0f172a";
    }
    function hexToRgb(hex){const s=hex.replace('#','');const n=parseInt(s,16);return {r:(n>>16)&255,g:(n>>8)&255,b:n&255};}
    function rgbToHsl(r,g,b){r/=255; g/=255; b/=255; const max=Math.max(r,g,b),min=Math.min(r,g,b); let h,s,l=(max+min)/2; if(max===min){h=s=0;} else{const d=max-min; s=l>0.5?d/(2-max-min):d/(max+min); switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break;} h/=6;} return {h,s,l};}
    function hslToHex(h,s,l){function f(n){const k=(n+h*12)%12; const a=s*Math.min(l,1-l); const c=l-a*Math.max(-1, Math.min(k-3, Math.min(9-k,1))); return Math.round(255*c).toString(16).padStart(2,'0');} return "#"+f(0)+f(8)+f(4);}
    function darkenHex(hex, amt=0.25){ const {r,g,b} = hexToRgb(hex); const {h,s,l} = rgbToHsl(r,g,b); const nl = Math.max(0, l - amt); return hslToHex(h,s,nl); }

    /* ä¾æ“šå¯¬åº¦èª¿æ•´å°éšŠæ¬„å¯¬ */
    function adjustSquadWidths(block) {
      const squadsContainer = block.querySelector('.squads');
      if (!squadsContainer) return;
      const squads = squadsContainer.querySelectorAll('.squad');
      const count = squads.length || 1;
      const width = window.innerWidth;

      if (width <= 768) {
        if (count <= 4) squads.forEach(sq => { sq.style.flex = "0 0 calc(21% - 6px)"; });
        else { const pct = 100 / count; squads.forEach(sq => { sq.style.flex = "0 0 calc(" + (pct - 4.8) + "%)"; }); }
        return;
      }
      if (width <= 1024) {
        if (count <= 4) squads.forEach(sq => { sq.style.flex = "0 0 calc(22.5% - 6px)"; });
        else { const pct = 100 / count; squads.forEach(sq => { sq.style.flex = "0 0 calc(" + (pct - 3.6) + "%)"; }); }
        return;
      }
      if (count <= 4) squads.forEach(sq => { sq.style.flex = "0 0 calc(23.5% - 6px)"; });
      else { const pct = 100 / count; squads.forEach(sq => { sq.style.flex = "0 0 calc(" + (pct - 2.3) + "%)"; }); }
    }
    window.addEventListener("resize", () => {
      document.querySelectorAll(".team-block").forEach(adjustSquadWidths);
    });

    function handlePanelInputChange(input){ input.dataset.dirty = "1"; clearHighlightOnEdit(input); saveState(); }
    function markDirty(el){ if (el) el.dataset.dirty = "1"; }

    function createMemberInputs(side){
      let html = "";
      for(let i=1;i<=6;i++){
        if(side === "last"){
          html += `
            <div class="member-row">
              <input data-role="name" data-side="last" class="locked-input" placeholder="æˆå“¡${i}" onclick="maybeOpenMemberPicker(event, this)" readonly>
            </div>
            <div class="member-row">
              <input data-role="skill" class="readonly-skill locked-input" placeholder="" readonly>
            </div>
          `;
        } else {
          html += `
            <div class="member-row">
              <input data-role="name" data-side="${side}" draggable="true"
                ondragstart="dragFromPanel(event)" ondragover="allowDrop(event)" ondrop="dropMember(event)"
                oncontextmenu="clearPanelCell(event)" oninput="handlePanelInputChange(this)" onclick="maybeOpenMemberPicker(event, this)" placeholder="æˆå“¡${i}">
            </div>
            <div class="member-row">
              <input data-role="skill" class="readonly-skill" placeholder="" readonly>
            </div>
          `;
        }
      }
      return html;
    }

    function createGroupTagSelect(selected="ä¸€åœ˜") {
      const opts = ["ä¸€åœ˜","äºŒåœ˜","ä¸‰åœ˜","å››åœ˜"];
      return `
        <select class="team-tag-select" onchange="markDirty(this); saveState()">
          ${opts.map(o => `<option value="${o}" ${o===selected?'selected':''}>${o}</option>`).join("")}
        </select>
      `;
    }

    function createSquad(idx, side, teamName){
      const sq = document.createElement("div");
      sq.className = "squad";
      sq.dataset.squad = idx;
      sq.innerHTML = `
        <div class="squad-title">ç¬¬${idx}å°éšŠ</div>
        ${side==="this" ? `<button class="squad-del-btn" onclick="deleteThisSquad(this)">Ã—</button>` : ""}
        ${createMemberInputs(side)}
      `;
      return sq;
    }

    function createTeamBlock(side, teamName, tag="ä¸€åœ˜"){
      const block = document.createElement("div");
      block.className = "team-block";
      block.dataset.team = teamName;
      block.dataset.side = side;
      const headColor = teamColorByName(teamName);
      block.innerHTML = `
        <div class="team-head" style="background:${headColor}">
          <div class="team-head-left">
            <span class="th-title">${side==="last"?"ä¸Šé€±ï¼":"æœ¬é€±ï¼"}${teamName}</span>
            ${side==="last" ? `<span class="team-tag-label">${tag}</span>` : createGroupTagSelect(tag)}
          </div>
          <div class="head-actions">
            ${side==="this" ? `<button class="head-add-btn" onclick="addSquadToTeamFromHead(this)">ï¼‹ æ–°å¢å°éšŠ</button>` : `<button class="head-add-btn disabled" disabled>ï¼‹ æ–°å¢å°éšŠ</button>`}
          </div>
        </div>
        <div class="squads"></div>
      `;
      const sqs = block.querySelector(".squads");
      for(let s=1;s<=3;s++){ sqs.appendChild(createSquad(s, side, teamName)); }
      block.dataset.lastSquadCount = "3";
      adjustSquadWidths(block);
      return block;
    }

    teams.forEach(t => {
      lastWeekPanel.appendChild(createTeamBlock("last", t));
      thisWeekPanel.appendChild(createTeamBlock("this", t));
    });

    function setupPanelCarousel(panelId) {
      const panel = document.getElementById(panelId);
      if (!panel) return;

      const blocks = Array.from(panel.querySelectorAll(".team-block"));
      if (!blocks.length) return;

      const wrap = document.createElement("div");
      wrap.className = "teams-wrap";
      blocks.forEach(b => wrap.appendChild(b));
      panel.appendChild(wrap);

      const dots = document.createElement("div");
      dots.className = "team-dots";
      panel.appendChild(dots);

      let current = 0;
      function show(index) {
        current = index;
        blocks.forEach((b, i) => { b.classList.toggle("active", i === index); });
        const allDots = dots.querySelectorAll(".team-dot");
        allDots.forEach((d, i) => { d.classList.toggle("active", i === index); });
      }

      blocks.forEach((b, idx) => {
        const dot = document.createElement("button");
        dot.type = "button";
        dot.className = "team-dot" + (idx === 0 ? " active" : "");
        dot.onclick = () => show(idx);
        dots.appendChild(dot);
      });

      let startX = 0, startY = 0, locked = false, isHorizontal = false;
      wrap.addEventListener("touchstart", function (e) {
        if (!e.touches || e.touches.length === 0) return;
        startX = e.touches[0].clientX; startY = e.touches[0].clientY; locked = false; isHorizontal = false;
      }, { passive: true });

      wrap.addEventListener("touchmove", function (e) {
        const t = e.touches && e.touches[0]; if (!t) return;
        const diffX = t.clientX - startX; const diffY = t.clientY - startY;
        if (!locked) { if (Math.abs(diffX) > 8 || Math.abs(diffY) > 8) { locked = true; isHorizontal = Math.abs(diffX) > Math.abs(diffY); } }
        if (locked && isHorizontal) e.preventDefault();
      }, { passive: false });

      wrap.addEventListener("touchend", function (e) {
        if (!locked || !isHorizontal) return;
        const endTouch = e.changedTouches && e.changedTouches[0]; if (!endTouch) return;
        const diffX = endTouch.clientX - startX; if (Math.abs(diffX) < 40) return;
        if (diffX < 0) { if (current < blocks.length - 1) show(current + 1); }
        else { if (current > 0) show(current - 1); }
      });

      show(0);
    }
    setupPanelCarousel("lastWeek");
    setupPanelCarousel("thisWeek");

    function renumberSquads(block){
      const sqs = block.querySelectorAll(".squad");
      sqs.forEach((sq,idx)=>{ sq.dataset.squad = idx+1; const title = sq.querySelector(".squad-title"); if(title) title.textContent = `ç¬¬${idx+1}å°éšŠ`; });
    }

    function addSquadToTeamFromHead(btn){
      const block = btn.closest(".team-block");
      const sqs = block.querySelector(".squads");
      const side = block.dataset.side;
      const teamName = block.dataset.team;
      const count = sqs.children.length;
      const newSq = createSquad(count + 1, side, teamName);
      newSq.dataset.newlyAdded = "1";
      sqs.appendChild(newSq);
      adjustSquadWidths(block);
      markDirty(block);
      saveState();
    }

    function deleteThisSquad(btn){
      const squad = btn.closest(".squad");
      const block = btn.closest(".team-block");
      const parent = squad.parentElement;
      if(confirm("ç¢ºå®šè¦åˆªé™¤é€™å€‹å°éšŠå—ï¼Ÿ")){
        parent.removeChild(squad);
        renumberSquads(block);
        adjustSquadWidths(block);
        markDirty(block);
        block.dataset.lastSquadCount = String(parent.children.length);
        saveState();
      }
    }

    function clearPanelCell(e){
      e.preventDefault();
      const input = e.target;
      if(input.dataset.role === "name" && input.dataset.side !== "last"){
        clearInputAndSkill(input);
        markDirty(input);
        saveState();
      }
    }

    function clearInputAndSkill(input){
      input.value = "";
      input.style.borderLeft = "";
      input.style.color = "";
      input.dataset.job = "";
      const skillRow = input.parentElement.nextElementSibling;
      if (skillRow && skillRow.querySelector("input[data-role='skill']")) {
        const skillInput = skillRow.querySelector("input[data-role='skill']");
        setSkillInputValue(skillInput, "");
      }
      input.classList.remove("highlight-new","highlight-missing");
    }

    function clearHighlightOnEdit(input){ input.classList.remove("highlight-new","highlight-missing"); }

    let subsPage = 1;
    const subsPerPage = 3;

    function createSubRow(name = "", skill = "", markDirty = false) {
      const row = document.createElement("div");
      row.className = "substitute-row";
      row.draggable = true;
      row.dataset.subIndex = subCounter++;
      if (markDirty) row.dataset.dirty = "1";
      row.ondragstart = dragFromSub;
      row.innerHTML = `
        <input class="sub-name" placeholder="æ›¿è£œæˆå“¡" value="${name}"
          ondragover="allowDrop(event)" ondrop="dropMember(event)" onblur="applyColorByName(this); markDirty(this); saveState();">
        <input class="sub-skill" placeholder="æŠ€èƒ½" value="${skill}" oninput="markDirty(this); saveState()">
        <button class="del-btn" onclick="deleteSub(this)">åˆª</button>
        <span class="sub-status"></span>
      `;
      applyColorByName(row.querySelector(".sub-name"));
      subsList.appendChild(row);
    }

    function refreshSubsView() {
      const rows = Array.from(subsList.children);
      const totalPages = Math.max(1, Math.ceil(rows.length / subsPerPage));
      if (subsPage > totalPages) subsPage = totalPages;
      rows.forEach((row, idx) => {
        const pageOfRow = Math.floor(idx / subsPerPage) + 1;
        row.style.display = (pageOfRow === subsPage) ? "grid" : "none";
      });
      const sel = document.getElementById("subsPageSelect");
      if (sel) {
        sel.innerHTML = "";
        for (let p = 1; p <= totalPages; p++) {
          const opt = document.createElement("option");
          opt.value = p;
          opt.textContent = "ç¬¬ " + p + " é ";
          if (p === subsPage) opt.selected = true;
          sel.appendChild(opt);
        }
      }
    }
    function subsPrev() { if (subsPage > 1) { subsPage--; refreshSubsView(); } }
    function subsNext() {
      const rows = Array.from(subsList.children);
      const totalPages = Math.max(1, Math.ceil(rows.length / subsPerPage));
      if (subsPage < totalPages) { subsPage++; refreshSubsView(); }
    }
    function subsJump(p) { subsPage = parseInt(p, 10) || 1; refreshSubsView(); }

    function addSub() { createSubRow("", "", true); saveState(); refreshSubsView(); }
    function deleteSub(btn) { subsList.removeChild(btn.parentElement); saveState(); refreshSubsView(); }

    function renderRoleTabs(){
      roleTabs.innerHTML = "";
      const allTab = document.createElement("div");
      allTab.className = "role-tab" + (activeRoleFilter==="" ? " active" : "");
      allTab.textContent = "å…¨éƒ¨";
      allTab.style.background = "#e2e8f0";
      allTab.onclick = ()=>{activeRoleFilter=""; memberPage=1; renderMemberList();};
      roleTabs.appendChild(allTab);
      Object.keys(roleColors).forEach(r=>{
        const tab = document.createElement("div");
        tab.className = "role-tab" + (activeRoleFilter===r ? " active" : "");
        tab.textContent = r;
        tab.style.background = roleColors[r];
        tab.onclick = ()=>{activeRoleFilter=r; memberPage=1; renderMemberList();};
        roleTabs.appendChild(tab);
      });
    }

    function getFilteredMembers(){
      const keyword = searchInput.value.trim();
      return allMembers.filter(m=>{
        const matchRole = !activeRoleFilter || m.job===activeRoleFilter;
        const matchText = !keyword || m.name.includes(keyword) || (m.skill && m.skill.includes(keyword));
        return matchRole && matchText;
      });
    }

    function renderMemberList(){
      const filtered = getFilteredMembers();
      const totalPages = Math.max(1, Math.ceil(filtered.length / pageSize));
      if(memberPage>totalPages) memberPage = totalPages;
      const start = (memberPage-1)*pageSize;
      const pageItems = filtered.slice(start, start+pageSize);

      memberList.innerHTML = "";
      pageItems.forEach(m=>{
        const item = document.createElement("div");
        item.className = "member-item";
        item.draggable = true;
        item.ondragstart = e => dragFromMemberList(e, m);
        const darkColor = m.job && roleColors[m.job] ? darkenHex(roleColors[m.job],0.25) : "#e2e8f0";
        item.style.borderLeft = "4px solid " + darkColor;
        item.innerHTML = `
          <div class="member-left" data-id="${m.id}">
            <div class="member-name" style="color:${darkColor}">${m.name}</div>
            <div class="member-skill">${m.skill || ""}</div>
          </div>
          <div class="member-actions" id="member-actions-${m.id}">
            <button onclick="startInlineEdit(${m.id})">ç·¨</button>
            <button onclick="deleteMember(${m.id})">åˆª</button>
          </div>
        `;
        memberList.appendChild(item);
      });

      const sel = document.getElementById("pageSelect");
      sel.innerHTML = "";
      for(let p=1;p<=totalPages && p<=8;p++){
        const opt = document.createElement("option");
        opt.value = p;
        opt.textContent = "ç¬¬ " + p + " é ";
        if(p===memberPage) opt.selected = true;
        sel.appendChild(opt);
      }
    }
    function prevPage(){ if(memberPage>1){ memberPage--; renderMemberList(); } }
    function nextPage(){
      const totalPages = Math.max(1, Math.ceil(getFilteredMembers().length / pageSize));
      if(memberPage<totalPages){ memberPage++; renderMemberList(); }
    }
    function jumpPage(p){ memberPage = parseInt(p,10); renderMemberList(); }

    function toggleAddMember(){
      const form = document.getElementById("addMemberForm");
      form.style.display = form.style.display==="flex" ? "none" : "flex";
    }
    function addMember(){
      const name = document.getElementById("newName").value.trim();
      const job = document.getElementById("newJob").value;
      const skill = document.getElementById("newSkill").value.trim();
      if(!name || !job){ alert("æˆå“¡åç¨±èˆ‡è·æ¥­å¿…å¡«"); return; }
      allMembers.push({id: ++nextMemberId, name, job, skill});
      document.getElementById("newName").value = "";
      document.getElementById("newJob").value = "";
      document.getElementById("newSkill").value = "";
      renderMemberList();
      document.getElementById("addMemberForm").style.display = "none";
      saveState();
    }

    function startInlineEdit(id){
      const item = [...memberList.querySelectorAll(".member-left")].find(div=>parseInt(div.dataset.id,10)===id);
      if(!item) return;
      const m = allMembers.find(x=>x.id===id);
      const actionArea = document.getElementById(`member-actions-${id}`);
      if(actionArea) actionArea.style.display = "none";
      item.innerHTML = `
        <input class="edit-input" id="edit-name-${id}" value="${m.name}">
        <select class="edit-input" id="edit-job-${id}">
          <option value="ä¹éˆ" ${m.job==="ä¹éˆ"?"selected":""}>ä¹éˆ</option>
          <option value="éµè¡£" ${m.job==="éµè¡£"?"selected":""}>éµè¡£</option>
          <option value="ç´ å•" ${m.job==="ç´ å•"?"selected":""}>ç´ å•</option>
          <option value="é¾åŸ" ${m.job==="é¾åŸ"?"selected":""}>é¾åŸ</option>
          <option value="ç¥ç›¸" ${m.job==="ç¥ç›¸"?"selected":""}>ç¥ç›¸</option>
          <option value="ç¢å¤¢" ${m.job==="ç¢å¤¢"?"selected":""}>ç¢å¤¢</option>
          <option value="è¡€æ²³" ${m.job==="è¡€æ²³"?"selected":""}>è¡€æ²³</option>
        </select>
        <input class="edit-input" id="edit-skill-${id}" value="${m.skill||""}">
        <div style="display:flex;gap:.3rem;">
          <button class="float-btn" style="font-size:.65rem;padding:.2rem .4rem;" onclick="saveInlineEdit(${id})">å„²å­˜</button>
          <button class="float-btn secondary" style="font-size:.65rem;padding:.2rem .4rem;" onclick="renderMemberList()">å–æ¶ˆ</button>
        </div>
      `;
    }
    function saveInlineEdit(id){
      const name = document.getElementById("edit-name-"+id).value.trim();
      const job = document.getElementById("edit-job-"+id).value.trim();
      const skill = document.getElementById("edit-skill-"+id).value.trim();
      const idx = allMembers.findIndex(x=>x.id===id);
      if(idx>-1){
        allMembers[idx] = {id, name, job, skill};
        renderMemberList();
        saveState();
      }
    }
    function deleteMember(id){
      const idx = allMembers.findIndex(x=>x.id===id);
      if(idx>-1){ allMembers.splice(idx,1); renderMemberList(); saveState(); }
    }

    function showDragPreview(text, color){
      dragPreviewEl = document.createElement("div");
      dragPreviewEl.className = "drag-preview";
      dragPreviewEl.textContent = text;
      dragPreviewEl.style.background = color || "#0f172a";
      document.body.appendChild(dragPreviewEl);
      document.addEventListener("dragover", movePreview);
    }
    function movePreview(e){ if(dragPreviewEl){ dragPreviewEl.style.left = e.pageX + 10 + "px"; dragPreviewEl.style.top = e.pageY + 10 + "px"; } }
    function hideDragPreview(){
      if(dragPreviewEl){
        document.body.removeChild(dragPreviewEl);
        dragPreviewEl = null;
        document.removeEventListener("dragover", movePreview);
      }
    }

    function dragFromMemberList(e, m){
      e.dataTransfer.setData("text/plain", JSON.stringify(m));
      const color = m.job && roleColors[m.job] ? darkenHex(roleColors[m.job],0.25) : "#0f172a";
      showDragPreview(`${m.name} (${m.job||""})`, color);
    }
    function dragFromSub(e){
      const row = e.currentTarget;
      const name = row.querySelector(".sub-name").value.trim();
      const skill = row.querySelector(".sub-skill").value.trim();
      if(!name){ e.preventDefault(); return; }
      const job = getJobByName(name) || row.querySelector(".sub-name").dataset.job || "";
      e.dataTransfer.setData("text/plain", JSON.stringify({name, skill, job, fromSub: row.dataset.subIndex}));
      const color = job && roleColors[job] ? darkenHex(roleColors[job],0.25) : "#0f172a";
      showDragPreview(`${name} (${job||""})`, color);
    }
    function dragFromPanel(e){
      const input = e.target;
      if(input.dataset.side === "last") { e.preventDefault(); return; }
      const side = input.dataset.side;
      const name = input.value.trim();
      let skill = "";
      const skillRow = input.parentElement.nextElementSibling;
      if(skillRow && skillRow.querySelector('input[data-role="skill"]')){
        skill = skillRow.querySelector('input[data-role="skill"]').value;
      }
      const job = input.dataset.job || getJobByName(name) || "";
      draggingPanelInput = input;
      draggingPanelSide = side;
      dragSuccess = false;
      e.dataTransfer.setData("text/plain", JSON.stringify({name, skill, job, fromPanel: true, side}));
      const color = job && roleColors[job] ? darkenHex(roleColors[job],0.25) : "#0f172a";
      showDragPreview(`${name || "ç©ºæ¬„ä½"} ${job? "(" + job + ")":""}`, color);
    }
    document.addEventListener("dragend", function(){
      hideDragPreview();
      if(draggingPanelInput && !dragSuccess){ clearInputAndSkill(draggingPanelInput); saveState(); }
      draggingPanelInput = null;
      draggingPanelSide = null;
    });

    function allowDrop(ev){ ev.preventDefault(); }

    function getJobByName(name){
      const m = allMembers.find(x=>x.name===name);
      return m ? m.job : "";
    }
    function applyJobColor(input, job){
      if(!input) return;
      if(job && roleColors[job]){
        const dark = darkenHex(roleColors[job],0.25);
        input.style.borderLeft = "6px solid " + dark;
        input.style.color = dark;
        input.style.fontWeight = "700";
        input.dataset.job = job;
      } else {
        input.style.borderLeft = "";
        input.style.color = "";
        input.dataset.job = "";
        input.style.fontWeight = "700";
      }
    }
    function applyColorByName(input){
      const name = input.value.trim();
      const job = getJobByName(name);
      applyJobColor(input, job);
    }

    function setSkillInputValue(input, val) {
      if (!input) return;
      input.value = val || "";
      if (val && val.trim() !== "") input.classList.add("skill-has");
      else input.classList.remove("skill-has");
    }

    function clearDuplicateInPanel(panelEl, name, exceptInput){
      panelEl.querySelectorAll("input[data-role='name']").forEach(inp=>{
        if(inp !== exceptInput && inp.value.trim() === name){
          clearInputAndSkill(inp);
        }
      });
    }

    function collectDirtyMarks() {
      const marks = [];
      thisWeekPanel.querySelectorAll("[data-dirty='1']").forEach(el => {
        const teamBlock = el.closest(".team-block");
        if (teamBlock) {
          const team = teamBlock.dataset.team;
          if (el.classList.contains("team-tag-select")) {
            marks.push({type:"team-tag", team});
          } else {
            const squadEl = el.closest(".squad");
            if (squadEl) {
              const squadIdx = Array.from(squadEl.parentElement.children).indexOf(squadEl);
              const nameInputs = squadEl.querySelectorAll("input[data-role='name']");
              const memberIdx = Array.from(nameInputs).indexOf(el);
              if (memberIdx !== -1) marks.push({type:"member", team, squad: squadIdx, member: memberIdx});
            }
          }
        }
      });
      thisWeekPanel.querySelectorAll(".team-block").forEach(block => {
        const team = block.dataset.team;
        const squads = block.querySelectorAll(".squad");
        squads.forEach((sqEl, idx) => {
          if (sqEl.dataset.newlyAdded === "1") {
            marks.push({ type: "squadNew", team, squad: idx });
            delete sqEl.dataset.newlyAdded;
          }
        });
        block.dataset.lastSquadCount = String(squads.length);
      });
      subsList.querySelectorAll("[data-dirty='1']").forEach(el => {
        const row = el.closest(".substitute-row");
        if (row) {
          const idx = Array.from(subsList.children).indexOf(row);
          marks.push({type:"sub", index: idx});
        }
      });
      return marks;
    }

    function renderRecentMarks(recentMarks) {
  clearAllOutlines();
  // ç·¨è¼¯æœŸé–“å…ˆä¸é¡¯ç¤ºæ¡†ç·šï¼Œç­‰ä¸‹ä¸€æ¬¡å„²å­˜æ‰ç•«
  if (outlinesSuppressed) return;
  if (!recentMarks || !recentMarks.user || !recentMarks.marks) return;
  const cls = OUTLINE_CLASS[recentMarks.user] || "outline-dabai";
  recentMarks.marks.forEach(m => {
    if (m.type === "member") {
      const block = thisWeekPanel.querySelector(`.team-block[data-team="${m.team}"]`);
      if (!block) return;
      const sq = block.querySelectorAll(".squads .squad")[m.squad];
      if (!sq) return;
      const inp = sq.querySelectorAll("input[data-role='name']")[m.member];
      if (inp) inp.classList.add(cls);
    } else if (m.type === "team-tag") {
      const block = thisWeekPanel.querySelector(`.team-block[data-team="${m.team}"]`);
      const sel = block && block.querySelector(".team-tag-select");
      if (sel) sel.classList.add(cls);
    } else if (m.type === "sub") {
      const row = subsList.children[m.index];
      if (row) row.classList.add(cls);
    } else if (m.type === "squadNew") {
      const block = thisWeekPanel.querySelector(`.team-block[data-team="${m.team}"]`);
      const newsq = block && block.querySelectorAll(".squad")[m.squad];
      if (newsq) {
        const title = newsq.querySelector(".squad-title");
        if (title) title.classList.add(cls);
      }
    }
  });
}


    function clearAllOutlines(){
      document.querySelectorAll(".outline-dabai, .outline-baoan, .outline-stitch").forEach(el=>{
        el.classList.remove("outline-dabai","outline-baoan","outline-stitch");
      });
    }

    function dropMember(ev){
      ev.preventDefault();
      dragSuccess = true;
      const data = ev.dataTransfer.getData("text/plain");
      if (!data) return;
      const member = JSON.parse(data);
      const target = ev.target;

      // â‘  æ›¿è£œå€
      if (target.classList.contains("sub-name")) {
        const prevName  = target.value.trim();
        const prevSkill = target.parentElement.querySelector(".sub-skill").value.trim();

        if (member.fromPanel && draggingPanelInput) {
          const oldName  = prevName;
          const oldSkill = prevSkill;
          const oldJob   = getJobByName(oldName) || target.dataset.job || "";

          target.value = member.name;
          applyJobColor(target, member.job);
          target.parentElement.querySelector(".sub-skill").value = member.skill || "";
          markDirty(target);

          draggingPanelInput.value = oldName;
          applyJobColor(draggingPanelInput, oldJob);
          const panelSkillRow = draggingPanelInput.parentElement.nextElementSibling;
          if (panelSkillRow && panelSkillRow.querySelector("input[data-role='skill']")) {
            setSkillInputValue(panelSkillRow.querySelector("input[data-role='skill']"), oldSkill || "");
          }
          markDirty(draggingPanelInput);

          clearDuplicateInPanel(thisWeekPanel, oldName, draggingPanelInput);
          saveState();
          return;
        }

        target.value = member.name;
        applyJobColor(target, member.job);
        const sk = target.parentElement.querySelector(".sub-skill");
        if (sk) sk.value = member.skill ? member.skill : "";
        markDirty(target);
        if (prevName) { clearDuplicateInPanel(thisWeekPanel, prevName, null); }
        saveState();
        return;
      }

      // â‘¡ é¢æ¿æ ¼
      if (target.dataset && target.dataset.role === "name") {
        const targetSide = target.dataset.side;
        if (targetSide === "last") return;

        const targetPanel = targetSide === "this" ? thisWeekPanel : lastWeekPanel;

        // åŒé¢æ¿äº’æ›
        if (member.fromPanel && member.side === targetSide && draggingPanelInput) {
          const src = draggingPanelInput;
          if (src === target) return;
          const srcName = src.value.trim();
          const srcJob  = src.dataset.job || getJobByName(srcName) || "";
          let srcSkill  = "";
          const srcSkillRow = src.parentElement.nextElementSibling;
          if (srcSkillRow && srcSkillRow.querySelector("input[data-role='skill']")) {
            srcSkill = srcSkillRow.querySelector("input[data-role='skill']").value;
          }
          const tgtName = target.value.trim();
          const tgtJob  = target.dataset.job || getJobByName(tgtName) || "";
          let tgtSkill  = "";
          const tgtSkillRow = target.parentElement.nextElementSibling;
          if (tgtSkillRow && tgtSkillRow.querySelector("input[data-role='skill']")) {
            tgtSkill = tgtSkillRow.querySelector("input[data-role='skill']").value;
          }
          src.value = tgtName; applyJobColor(src, tgtJob);
          target.value = srcName; applyJobColor(target, srcJob);
          if (srcSkillRow && srcSkillRow.querySelector("input[data-role='skill']")) { setSkillInputValue(srcSkillRow.querySelector("input[data-role='skill']"), tgtSkill || ""); }
          if (tgtSkillRow && tgtSkillRow.querySelector("input[data-role='skill']")) { setSkillInputValue(tgtSkillRow.querySelector("input[data-role='skill']"), srcSkill || ""); }
          src.classList.remove("highlight-new", "highlight-missing");
          target.classList.remove("highlight-new", "highlight-missing");
          markDirty(src); markDirty(target); saveState();
          return;
        }

        // æ›¿è£œ â†’ é¢æ¿ ä¸”ç›®æ¨™æ ¼åŸæœ¬æœ‰å€¼ï¼Œè¦æ›å›å»æ›¿è£œ
        if (member.fromSub !== undefined && target.value.trim() !== "") {
          const oldName = target.value.trim();
          const oldJob  = target.dataset.job || getJobByName(oldName) || "";
          let oldSkill  = "";
          const skillRow = target.parentElement.nextElementSibling;
          if (skillRow && skillRow.querySelector("input[data-role='skill']")) {
            oldSkill = skillRow.querySelector("input[data-role='skill']").value;
          }
          const subRow = subsList.querySelector(`[data-sub-index="${member.fromSub}"]`);
          if (subRow) {
            subRow.querySelector(".sub-name").value = oldName;
            applyJobColor(subRow.querySelector(".sub-name"), oldJob);
            subRow.querySelector(".sub-skill").value = oldSkill;
            markDirty(subRow.querySelector(".sub-name"));
          }
        }

        // ä¸åŒé¢æ¿ä¸äº¤æ›
        if (member.fromPanel && member.side !== targetSide) return;

        // çœŸæ­£æ”¾é€²é¢æ¿
        target.value = member.name;
        applyJobColor(target, member.job);
        const srow = target.parentElement.nextElementSibling;
        if (srow && srow.querySelector("input[data-role='skill']")) {
          setSkillInputValue(srow.querySelector("input[data-role='skill']"), member.skill ? member.skill : "");
        }
        clearDuplicateInPanel(thisWeekPanel, member.name, target);
        target.classList.remove("highlight-new", "highlight-missing");
        clearDuplicateInPanel(targetPanel, member.name, target);
        markDirty(target);
        saveState();
      }
    }

    function getPanelData(panelEl){
      const data = [];
      panelEl.querySelectorAll(".team-block").forEach(block=>{
        const team = block.dataset.team;
        const tagSelect = block.querySelector(".team-tag-select");
        const label = block.querySelector(".team-tag-label");
        const groupTag = tagSelect ? tagSelect.value : (label ? label.textContent.trim() : "ä¸€åœ˜");
        const squads = [];
        block.querySelectorAll(".squads .squad").forEach(sq=>{
          const members = [];
          sq.querySelectorAll("input[data-role='name']").forEach(nameInput=>{
            const skillRow = nameInput.parentElement.nextElementSibling;
            const skillInput = skillRow ? skillRow.querySelector("input[data-role='skill']") : null;
            members.push({
              name: nameInput.value.trim(),
              job: nameInput.dataset.job || "",
              skill: skillInput ? (skillInput.value.trim() || "") : ""
            });
          });
          squads.push({members});
        });
        data.push({team, tag: groupTag, squads});
      });
      return data;
    }

    function setPanelData(panelEl, data, side){
      data.forEach(teamData=>{
        const block = panelEl.querySelector(`.team-block[data-team="${teamData.team}"]`);
        if(!block) return;
        if (side === "this") {
          const tagSelect = block.querySelector(".team-tag-select");
          if (tagSelect && teamData.tag) tagSelect.value = teamData.tag;
        } else {
          const label = block.querySelector(".team-tag-label");
          if (label && teamData.tag) label.textContent = teamData.tag;
        }
        const squadsContainer = block.querySelector(".squads");
        let currentCount = squadsContainer.children.length;
        const neededCount = teamData.squads.length;
        while(currentCount < neededCount){ squadsContainer.appendChild(createSquad(currentCount+1, side, teamData.team)); currentCount++; }
        while(squadsContainer.children.length > neededCount){ squadsContainer.removeChild(squadsContainer.lastElementChild); }
        teamData.squads.forEach((sqData, idx)=>{
          const sqEl = squadsContainer.children[idx];
          const nameInputs = sqEl.querySelectorAll("input[data-role='name']");
          nameInputs.forEach((inp, mIdx)=>{
            const member = sqData.members[mIdx];
            if(member){
              inp.value = member.name || "";
              if(side==="last"){ inp.classList.add("locked-input"); inp.readOnly = true; }
              if(member.job){ applyJobColor(inp, member.job); } else { applyColorByName(inp); }
              const skillRow = inp.parentElement.nextElementSibling;
              if(skillRow && skillRow.querySelector("input[data-role='skill']")){
                setSkillInputValue(skillRow.querySelector("input[data-role='skill']"), member.skill ? member.skill : "");
                if(side==="last"){ const si = skillRow.querySelector("input[data-role='skill']"); si.readOnly = true; si.classList.add("locked-input"); }
              }
            } else {
              clearInputAndSkill(inp);
            }
          });
        });
        renumberSquads(block);
        block.dataset.lastSquadCount = String(neededCount || 3);
        adjustSquadWidths(block);
      });
    }

    function getSubsData(){
      const arr = [];
      subsList.querySelectorAll(".substitute-row").forEach(row=>{
        arr.push({ name: row.querySelector(".sub-name").value.trim(), skill: row.querySelector(".sub-skill").value.trim() });
      });
      return arr;
    }

    function saveState(){
      const state = { allMembers, lastWeek: getPanelData(lastWeekPanel), thisWeek: getPanelData(thisWeekPanel), subs: getSubsData() };
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); } catch(e){}
    }

    function fetchWithTimeout(url, ms=3000){
      const ctrl = new AbortController();
      const id = setTimeout(()=>ctrl.abort(), ms);
      return fetch(url, {signal: ctrl.signal}).finally(()=>clearTimeout(id));
    }

    /* å–å¾—æ›è·åå–®ç‰©ä»¶ */
    function getStuckData(){
      try { const raw = localStorage.getItem(STORAGE_STUCK_KEY); if (raw) return JSON.parse(raw); } catch(e){}
      return {};
    }
    function setStuckData(obj){ try { localStorage.setItem(STORAGE_STUCK_KEY, JSON.stringify(obj || {})); } catch(e){} }

    /* æœ¬é€±æ‰€æœ‰åå­— Setï¼ˆå«ç©ºç™½æ¿¾é™¤ï¼‰ */
    function getThisWeekNameSet(){
      const set = new Set();
      thisWeekPanel.querySelectorAll("input[data-role='name']").forEach(inp=>{
        const v = inp.value.trim(); if(v) set.add(v);
      });
      return set;
    }

    /* æ›è·åå–®åˆ—è¡¨æ¸²æŸ“ï¼šè‹¥è©²äººæœ¬é€±æœ‰ä¸Šå ´ â†’ æš«æ™‚éš±è—ï¼›é»æ“Šåªåˆ‡æ›æ¨£å¼ï¼Œä¸åˆªé™¤ */
    function renderStuckList(){
  const box = document.getElementById("stuckList");
  if (!box) return;
  const data = getStuckData();
  const names = Object.keys(data);
  const thisSet = getThisWeekNameSet();
  box.innerHTML = "";
  if (!names.length) {
    box.innerHTML = '<span style="font-size:.7rem;color:#94a3b8;">ç›®å‰ç„¡æ›è·æˆå“¡</span>';
    return;
  }
  names.forEach(name => {
    if (thisSet.has(name)) { /* æš«æ™‚éš±è— */ return; }
    const tag = document.createElement("div");
    tag.className = "compare-tag missing-tag";
    if (compareIgnore.has(name)) tag.classList.add("muted");
    tag.textContent = name;
    tag.title = "é»æ“Šåˆ‡æ›æ¨£å¼ï¼ˆä¸æœƒåˆªé™¤ï¼‰";
    tag.onclick = function(){
      // é»æ“Šæ›è·åå–®çš„æ¨™ç±¤ï¼šä¹Ÿè¦æŠŠæ‰€æœ‰ã€Œæœ€è¿‘ä¿®æ”¹æ¡†ç·šã€éš±è—
      suppressOutlinesOnEdit();
      toggleStuckMute(name);
    };
    box.appendChild(tag);
  });
}


    /* åˆ‡æ›æ›è·åå–®çš„ muted æ¨£å¼ï¼ˆå¯«å…¥ compareIgnoreï¼Œä¸åˆªé™¤è³‡æ–™ï¼‰ */
    function toggleStuckMute(name){
  // ç„¡è«–å¾å“ªè£¡å‘¼å«ï¼Œåˆ‡æ›æ›è·æ¨™ç±¤æ™‚éƒ½éš±è—æœ€è¿‘ä¿®æ”¹æ¡†ç·š
  suppressOutlinesOnEdit();
  if (compareIgnore.has(name)) compareIgnore.delete(name);
  else compareIgnore.add(name);
  localStorage.setItem(STORAGE_IGNORE_KEY, JSON.stringify(Array.from(compareIgnore)));
  renderStuckList();
}


    function loadPersistentIgnore(){
      try {
        const raw = localStorage.getItem(STORAGE_IGNORE_KEY);
        if (raw) {
          const arr = JSON.parse(raw);
          persistentCompareIgnore = new Set(arr);
          compareIgnore.clear();
          arr.forEach(n => compareIgnore.add(n));
        }
      } catch(e){
        persistentCompareIgnore = new Set();
      }
    }

    function applyStateToPage(state, fromLocal){
      if (state.allMembers && Array.isArray(state.allMembers)) {
        allMembers = state.allMembers;
        const maxId = allMembers.reduce((m,c)=>Math.max(m,c.id||0),12);
        nextMemberId = maxId + 1;
      }
      renderMemberList();

      if (state.lastWeek) {
        setPanelData(lastWeekPanel, state.lastWeek, "last");
        lastWeekPanel.querySelectorAll(".team-block").forEach(adjustSquadWidths);
      }
      if (state.thisWeek) {
        setPanelData(thisWeekPanel, state.thisWeek, "this");
        thisWeekPanel.querySelectorAll(".team-block").forEach(adjustSquadWidths);
      }

      subsList.innerHTML = "";
      if (state.subs && state.subs.length) {
        state.subs.forEach(su => createSubRow(su.name, su.skill, false));
      }
      refreshSubsView();

      if (state.recentMarks) renderRecentMarks(state.recentMarks);
      else clearAllOutlines();

      if (state.compareIgnore && Array.isArray(state.compareIgnore)) {
        persistentCompareIgnore = new Set(state.compareIgnore);
        compareIgnore.clear();
        state.compareIgnore.forEach(n => compareIgnore.add(n));
        localStorage.setItem(STORAGE_IGNORE_KEY, JSON.stringify(state.compareIgnore));
      }

      if (state.stuckMembers) setStuckData(state.stuckMembers);
      renderStuckList();
    }

    function saveCompareIgnore(){
      const arr = Array.from(compareIgnore);
      localStorage.setItem(STORAGE_IGNORE_KEY, JSON.stringify(arr));
      requestSave();
    }

    function requestSave(){
      const now = Date.now();
      if (currentUser && (now - lastLoginTime) < LOGIN_TTL) {
        doSaveToBackend();
      } else {
        showLogin();
      }
    }
    function showLogin(){
      document.getElementById("loginMsg").textContent = "";
      document.getElementById("loginUser").value = "";
      document.getElementById("loginPass").value = "";
      document.getElementById("loginModal").style.display = "flex";
      document.getElementById("loginUser").focus();
    }
    function closeLogin(){ document.getElementById("loginModal").style.display = "none"; }

    function doLogin(){
      const u = document.getElementById("loginUser").value.trim();
      const p = document.getElementById("loginPass").value.trim();
      fetch(REMOTE_API, {
        method: "POST",
        body: JSON.stringify({ action: "login", user: u, pass: p })
      })
      .then(r => r.json())
      .then(data => {
        if (data && data.success && data.user) {
          currentUser = data.user;
          lastLoginTime = Date.now();
          localStorage.setItem(LOGIN_STORAGE_KEY, JSON.stringify({user: currentUser, time: lastLoginTime}));
          closeLogin();
          doSaveToBackend();
        } else {
          document.getElementById("loginMsg").textContent = "å¸³è™Ÿæˆ–å¯†ç¢¼éŒ¯èª¤";
        }
      })
      .catch(err => {
        console.warn("login error", err);
        document.getElementById("loginMsg").textContent = "ç™»å…¥å¤±æ•—";
      });
    }

    function doSaveToBackend(){
      const state = {
        allMembers,
        lastWeek: getPanelData(lastWeekPanel),
        thisWeek: getPanelData(thisWeekPanel),
        subs: getSubsData()
      };
      const marks = collectDirtyMarks();
      state.recentMarks = { user: currentUser || "unknown", marks };
      state.compareIgnore = Array.from(compareIgnore);
      state.stuckMembers = getStuckData();

      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); } catch(e){}

      fetch(REMOTE_API, {
        method: "POST",
        body: JSON.stringify({ action: "save", payload: state })
      })
      .then(res=>res.json())
      .then(data=>{
      if (data && data.success) {
      alert("å·²å„²å­˜åˆ°å¾Œå°");
      // è§£é™¤æŠ‘åˆ¶ï¼Œå„²å­˜å¾Œæ¢å¾©é¡¯ç¤ºæœ€è¿‘ä¿®æ”¹æ¡†ç·š
      outlinesSuppressed = false;
      renderRecentMarks(state.recentMarks);
      document.querySelectorAll("[data-dirty='1']").forEach(el=>el.removeAttribute("data-dirty"));
      localStorage.setItem(STORAGE_IGNORE_KEY, JSON.stringify(state.compareIgnore || []));
      setStuckData(state.stuckMembers || {});
      renderStuckList();
      } else {
      alert("å¾Œå°æœ‰å›æ‡‰ä½†ä¸æ˜¯ successï¼Œè«‹çœ‹ console");
      console.log(data);
        }
      })

      .catch(err=>{
        alert("ç„¡æ³•é€£åˆ°å¾Œå°ï¼Œè«‹æª¢æŸ¥ Apps Script éƒ¨ç½²æ¬Šé™");
        console.error(err);
      });
    }

    /* æ¯”å°ï¼šè‹¥æ›è·åå–®æˆå“¡æœ¬é€±æœ‰ä¸Šå ´ â†’ å¾…è™•ç†åå–®èˆ‡æ›è·åå–®éƒ½æš«æ™‚éš±è— */
    function compare(){
  // æŒ‰ä¸‹æ¯”å°ï¼šç«‹åˆ»éš±è—æ‰€æœ‰ã€Œæœ€è¿‘ä¿®æ”¹æ¡†ç·šã€
  suppressOutlinesOnEdit(); // æœƒæŠŠ outlinesSuppressed è¨­ç‚º true ä¸¦å‘¼å« clearAllOutlines()
  document.querySelectorAll("input[data-role='name']").forEach(inp=>{
    inp.classList.remove("highlight-new","highlight-missing");
  });

  const lastNames = [];
  lastWeekPanel.querySelectorAll("input[data-role='name']").forEach(inp=>{
    const v = inp.value.trim(); if(v) lastNames.push(v);
  });
  const lastSet = new Set(lastNames);
  const thisNames = [];
  thisWeekPanel.querySelectorAll("input[data-role='name']").forEach(inp=>{
    const v = inp.value.trim(); if(v) thisNames.push({val:v, el:inp});
  });
  const thisSet = new Set(thisNames.map(x=>x.val));
  const stuck = getStuckData();
  const stuckSet = new Set(Object.keys(stuck));
  const newOnes = [];
  const missingOnes = [];
  // æ–°å¢ï¼šæ’é™¤ã€ŒåŒæ™‚åœ¨æ›è·åå–®ã€çš„äººï¼ˆ3-1ï¼‰
  thisNames.forEach(obj=>{
    if (obj.val && !lastSet.has(obj.val)) {
      if (!stuckSet.has(obj.val)) { // åªè¦ä¸æ˜¯æ›è·åå–®ï¼Œå°±ä¾ compareIgnore ä¸Šè‰²
        if (!compareIgnore.has(obj.val)) obj.el.classList.add("highlight-new");
        newOnes.push(obj.val);
      }
    }
  });
  // ç¼ºå¸­ï¼šç¶­æŒåŸé‚è¼¯ï¼ˆæ›è·è€…ä»å¯é¡¯ç¤ºç‚ºç¼ºå¸­ç´…æ¨™ï¼›æ›è·åˆ—è¡¨å¦åˆ—ï¼‰
  lastWeekPanel.querySelectorAll("input[data-role='name']").forEach(inp=>{
    const v = inp.value.trim();
    if (v && !thisSet.has(v)) {
      if (!compareIgnore.has(v)) inp.classList.add("highlight-missing");
      missingOnes.push(v);
    }
  });
  // æ›¿è£œæ¨™ç¤º
  subsList.querySelectorAll(".substitute-row").forEach(row=>{
    const name = row.querySelector(".sub-name").value.trim();
    const status = row.querySelector(".sub-status");
    if(!name){ status.textContent = ""; return; }
    if(thisSet.has(name)){ status.textContent = "æœ¬é€±å·²ä¸Šå ´ âœ…"; status.style.color = "#16a34a"; }
    else { status.textContent = "æœ¬é€±æœªä¸Šå ´"; status.style.color = "#b91c1c"; }
  });
  renderCompareTags(newOnes, missingOnes);
  currentMissingNotIgnored = missingOnes.filter(name => !compareIgnore.has(name));
  // æ›è·åå–®åŒæ­¥ï¼ˆå°æ–¼ã€Œæœ¬é€±æœ‰ä¸Šå ´ã€è€…æš«æ™‚éš±è—ï¼‰
  renderStuckList();
}


    function renderCompareTags(newList, missingList){
      compareTagsEl.innerHTML = "";
      newList.forEach(name => {
        const tag = document.createElement("div");
        tag.className = "compare-tag new-tag" + (compareIgnore.has(name) ? " muted" : "");
        tag.textContent = name;
        tag.onclick = () => toggleCompareIgnore(name);
        compareTagsEl.appendChild(tag);
      });
      missingList.forEach(name => {
        const tag = document.createElement("div");
        tag.className = "compare-tag missing-tag" + (compareIgnore.has(name) ? " muted" : "");
        tag.textContent = name;
        tag.onclick = () => toggleCompareIgnore(name);
        compareTagsEl.appendChild(tag);
      });
    }

    function toggleCompareIgnore(name){
  // é»æ“Šå¾…è™•ç†åå–®çš„æ¨™ç±¤ï¼šä¹Ÿè¦æŠŠæ‰€æœ‰ã€Œæœ€è¿‘ä¿®æ”¹æ¡†ç·šã€éš±è—
  suppressOutlinesOnEdit();
  if (compareIgnore.has(name)) compareIgnore.delete(name);
  else {
    compareIgnore.add(name);
    document.querySelectorAll("input[data-role='name']").forEach(inp=>{
      if (inp.value.trim() === name) { inp.classList.remove("highlight-new","highlight-missing"); }
    });
  }
  compare();
}


    /* è¦†è“‹å¾Œï¼š1) æ–°ç¼ºå¸­åŠ å…¥æ›è·ï¼› 2) æœ¬é€±æœ‰ä¸Šå ´è€…å¾æ›è·æ­£å¼ç§»é™¤ï¼›2.5) å–æ¶ˆç‹€æ…‹æŒçºŒåˆ°è¦†è“‹ â†’ è¦–ç‚ºæ²’è·ä½ï¼Œå¾æ›è·åå–®åˆªé™¤ï¼› 3) æ¸…ç©º compareIgnoreï¼ˆé‡ç½®ç‹€æ…‹ï¼‰ */
function copyThisToLast(){
  if(!confirm("ç¢ºå®šè¦ç”¨ã€æœ¬é€±åå–®ã€è¦†è“‹ã€ä¸Šé€±åå–®ã€å—ï¼Ÿ")) return;
  lastSnapshot = JSON.stringify(getPanelData(lastWeekPanel));

  const stuck = getStuckData();
  // 1) å°‡æœ¬æ¬¡æ¯”å°ã€Œæœªå¿½ç•¥ã€çš„ç¼ºå¸­è€…åŠ å…¥æ›è·
  currentMissingNotIgnored.forEach(name => {
    if (name && !stuck[name]) { stuck[name] = new Date().toISOString(); }
  });
  // 2) æ­£å¼ç§»é™¤ï¼šè‹¥æ›è·è€…æœ¬é€±æœ‰ä¸Šå ´ â†’ å¾æ›è·åå–®åˆªé™¤
  const thisSet = getThisWeekNameSet();
  Object.keys(stuck).forEach(n => { if (thisSet.has(n)) delete stuck[n]; });
  // 2.5) è‹¥æ›è·è€…è¢«ä½ é»ã€Œå–æ¶ˆã€ï¼ˆmuted = åœ¨ compareIgnore Set è£¡ï¼‰ï¼Œ
  // ä¸”åœ¨è¦†è“‹é€™ä¸€åˆ»ä»æ˜¯å–æ¶ˆç‹€æ…‹ â†’ è¦–ç‚ºå·²ç„¡è·ä½ï¼Œç›´æ¥å¾æ›è·åå–®åˆªé™¤
  Object.keys(stuck).forEach(n => {
    if (compareIgnore.has(n)) { delete stuck[n]; }
  });
  setStuckData(stuck);
  // 3) æ¸…ç©º compareIgnoreï¼ˆé‡ç½®æ‰€æœ‰è¢«å–æ¶ˆçš„æ¨™ç±¤ç‹€æ…‹ï¼‰
  resetCompareIgnoreAfterCopy();
  // å¯¦éš›è¦†è“‹ UI
  const thisData = getPanelData(thisWeekPanel);
  setPanelData(lastWeekPanel, thisData, "last");
  saveState();
  renderStuckList();
  alert("å·²å°‡æœ¬é€±åå–®è¦†è“‹åˆ°ä¸Šé€±ã€‚æ¨™ç±¤ç‹€æ…‹å·²é‡ç½®ã€‚");
}

    function resetCompareIgnoreAfterCopy(){
      compareIgnore.clear();
      localStorage.setItem(STORAGE_IGNORE_KEY, JSON.stringify([]));
      renderCompareTags([], []); // æ¸…ç©ºå‘ˆç¾
    }

    function undoCopy(){
      if(!lastSnapshot){ alert("æ²’æœ‰å¯é‚„åŸçš„å…§å®¹ã€‚"); return; }
      const data = JSON.parse(lastSnapshot);
      setPanelData(lastWeekPanel, data, "last");
      saveState();
      alert("å·²é‚„åŸåˆ°è¦†è“‹å‰çš„ä¸Šé€±åå–®ã€‚");
    }

    function startVersionWatcher(){
      const INTERVAL = 4000;
      setInterval(async ()=>{
        try {
          const res = await fetch(REMOTE_API + "?action=version");
          const data = await res.json();
          if (data && data.success) {
            const serverUpdatedAt = data.updatedAt || null;
            if (!lastKnownUpdatedAt) { lastKnownUpdatedAt = serverUpdatedAt; return; }
            if (serverUpdatedAt && serverUpdatedAt !== lastKnownUpdatedAt) {
              const fullRes = await fetch(REMOTE_API + "?action=get");
              const fullData = await fullRes.json();
              if (fullData && fullData.success && fullData.payload) {
                applyStateToPage(fullData.payload, false);
                localStorage.setItem(STORAGE_KEY, JSON.stringify(fullData.payload));
                lastKnownUpdatedAt = serverUpdatedAt;
              }
            }
          }
        } catch(err){ console.warn("æª¢æŸ¥ç‰ˆæœ¬å¤±æ•—", err); }
      }, INTERVAL);
    }

    function fillRoundRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
      ctx.fill();
    }
  // åªæé‚Šåœ“è§’çŸ©å½¢ï¼ˆæ­é… fillRoundRect ä½¿ç”¨ï¼‰
function strokeRoundRect(ctx, x, y, w, h, r, color = "#e2e8f0") {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.stroke();
}

    /* V14.6å¯æŒ‡å®šå››å€‹è§’çš„åœ“è§’ path */
function roundRectPath(ctx, x, y, w, h, r, corners = {tl:true,tr:true,br:true,bl:true}) {
  const tl = corners.tl ? r : 0, tr = corners.tr ? r : 0, br = corners.br ? r : 0, bl = corners.bl ? r : 0;
  ctx.beginPath();
  ctx.moveTo(x + tl, y);
  ctx.lineTo(x + w - tr, y);
  if (tr) ctx.quadraticCurveTo(x + w, y, x + w, y + tr); else ctx.lineTo(x + w, y);
  ctx.lineTo(x + w, y + h - br);
  if (br) ctx.quadraticCurveTo(x + w, y + h, x + w - br, y + h); else ctx.lineTo(x + w, y + h);
  ctx.lineTo(x + bl, y + h);
  if (bl) ctx.quadraticCurveTo(x, y + h, x, y + h - bl); else ctx.lineTo(x, y + h);
  ctx.lineTo(x, y + tl);
  if (tl) ctx.quadraticCurveTo(x, y, x + tl, y); else ctx.lineTo(x, y);
  ctx.closePath();
}
function fillRoundRectCorners(ctx, x, y, w, h, r, corners) {
  roundRectPath(ctx, x, y, w, h, r, corners);
  ctx.fill();
}


    
/* 1px è¦–è¦ºç­‰å¯¬ï¼šåœ“è§’çŸ©å½¢æé‚Šï¼ˆåƒç´ å°é½Šï¼‰ */
function strokeRoundedCrisp(ctx, x, y, w, h, r, corners = {tl:true,tr:true,br:true,bl:true}, color = "#e2e8f0") {
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;           // å›ºå®šè¦–è¦º 1px
  ctx.lineJoin = "round";
  ctx.lineCap  = "round";
  // è®“æ•´å€‹å¤–æ¡†å¾€å³ä¸‹å„å°é½ŠåŠåƒç´ ï¼Œé¿å…æ›²ç·šè¢«æŠ—é‹¸é½’åƒå¯¬
  // åŒæ™‚ç¸®å° w/h 1pxï¼Œç¢ºä¿ç·šå¿ƒéƒ½è½åœ¨åƒç´ é‚Šç•Œ
  const tl = corners.tl ? r : 0, tr = corners.tr ? r : 0, br = corners.br ? r : 0, bl = corners.bl ? r : 0;
  const _x = x + 0.5, _y = y + 0.5, _w = Math.max(0, w - 1), _h = Math.max(0, h - 1);
  const _r = Math.max(0, r - 0.5);
  ctx.beginPath();
  ctx.moveTo(_x + (corners.tl ? _r : 0), _y);
  ctx.lineTo(_x + _w - (corners.tr ? _r : 0), _y);
  if (tr) ctx.arcTo(_x + _w, _y, _x + _w, _y + (tr ? _r : 0), _r); else ctx.lineTo(_x + _w, _y);
  ctx.lineTo(_x + _w, _y + _h - (corners.br ? _r : 0));
  if (br) ctx.arcTo(_x + _w, _y + _h, _x + _w - (br ? _r : 0), _y + _h, _r); else ctx.lineTo(_x + _w, _y + _h);
  ctx.lineTo(_x + (corners.bl ? _r : 0), _y + _h);
  if (bl) ctx.arcTo(_x, _y + _h, _x, _y + (bl ? _r : 0), _r); else ctx.lineTo(_x, _y + _h);
  ctx.lineTo(_x, _y + (corners.tl ? _r : 0));
  if (tl) ctx.arcTo(_x, _y, _x + (tl ? _r : 0), _y, _r); else ctx.lineTo(_x, _y);
  ctx.stroke();
  ctx.restore();
}


    

/* 1px è¦–è¦ºç­‰å¯¬ï¼šåªç•«æŒ‡å®šé‚Šï¼ˆåƒç´ å°é½Šç›´ç·šï¼‰ */
function strokeEdgesCrisp(ctx, x, y, w, h, edges, color = "#e2e8f0") {
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;           // å›ºå®šè¦–è¦º 1px
  ctx.beginPath();
  // ç›´ç·šéƒ½è½åœ¨ 0.5 offsetï¼Œç¢ºä¿éŠ³åˆ©
  if (edges.top)    { ctx.moveTo(x + 0.5, y + 0.5);         ctx.lineTo(x + w - 0.5, y + 0.5); }
  if (edges.right)  { ctx.moveTo(x + w - 0.5, y + 0.5);     ctx.lineTo(x + w - 0.5, y + h - 0.5); }
  if (edges.bottom) { ctx.moveTo(x + 0.5, y + h - 0.5);     ctx.lineTo(x + w - 0.5, y + h - 0.5); }
  if (edges.left)   { ctx.moveTo(x + 0.5, y + 0.5);         ctx.lineTo(x + 0.5, y + h - 0.5); }
  ctx.stroke();
  ctx.restore();
}

    
//ä»¥ä¸‹é€™æ®µ V14.7 ä¸‹è¼‰åœ–ç‰‡åŠŸèƒ½ï¼ˆå«åœ“è§’å‹å–„æé‚Š / è¦–è¦ºç­‰ç²—ï¼‰
// ================== 1) å·¥å…·ï¼šåƒç´ å°é½Šæé‚Š ==================
function strokeRoundedCrisp(ctx, x, y, w, h, r, corners = {tl:true,tr:true,br:true,bl:true}, color = "#e2e8f0") {
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.lineJoin = "round";
  ctx.lineCap  = "round";

  const tl = corners.tl ? r : 0, tr = corners.tr ? r : 0, br = corners.br ? r : 0, bl = corners.bl ? r : 0;
  const _x = x + 0.5, _y = y + 0.5, _w = Math.max(0, w - 1), _h = Math.max(0, h - 1);
  const _rtl = Math.max(0, tl - 0.5), _rtr = Math.max(0, tr - 0.5), _rbr = Math.max(0, br - 0.5), _rbl = Math.max(0, bl - 0.5);

  ctx.beginPath();
  // top
  ctx.moveTo(_x + (tl ? _rtl : 0), _y);
  ctx.lineTo(_x + _w - (tr ? _rtr : 0), _y);
  if (tr) ctx.arcTo(_x + _w, _y, _x + _w, _y + _rtr, _rtr); else ctx.lineTo(_x + _w, _y);
  // right
  ctx.lineTo(_x + _w, _y + _h - (br ? _rbr : 0));
  if (br) ctx.arcTo(_x + _w, _y + _h, _x + _w - _rbr, _y + _h, _rbr); else ctx.lineTo(_x + _w, _y + _h);
  // bottom
  ctx.lineTo(_x + (bl ? _rbl : 0), _y + _h);
  if (bl) ctx.arcTo(_x, _y + _h, _x, _y + _h - _rbl, _rbl); else ctx.lineTo(_x, _y + _h);
  // left
  ctx.lineTo(_x, _y + (tl ? _rtl : 0));
  if (tl) ctx.arcTo(_x, _y, _x + _rtl, _y, _rtl); else ctx.lineTo(_x, _y);
  ctx.stroke();
  ctx.restore();
}

function strokeEdgesCrisp(ctx, x, y, w, h, edges, color = "#e2e8f0") {
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.beginPath();
  if (edges.top)    { ctx.moveTo(x + 0.5, y + 0.5);         ctx.lineTo(x + w - 0.5, y + 0.5); }
  if (edges.right)  { ctx.moveTo(x + w - 0.5, y + 0.5);     ctx.lineTo(x + w - 0.5, y + h - 0.5); }
  if (edges.bottom) { ctx.moveTo(x + 0.5, y + h - 0.5);     ctx.lineTo(x + w - 0.5, y + h - 0.5); }
  if (edges.left)   { ctx.moveTo(x + 0.5, y + 0.5);         ctx.lineTo(x + 0.5, y + h - 0.5); }
  ctx.stroke();
  ctx.restore();
}

// ä½ å·²ç¶“æœ‰çš„å››è§’åœ“å·¥å…·ï¼šroundRectPath / fillRoundRectCorners ï¼ˆæ²¿ç”¨ç¾æˆçš„ï¼‰
function roundRectPath(ctx, x, y, w, h, r, corners = {tl:true,tr:true,br:true,bl:true}) {
  const tl = corners.tl ? r : 0, tr = corners.tr ? r : 0, br = corners.br ? r : 0, bl = corners.bl ? r : 0;
  ctx.beginPath();
  ctx.moveTo(x + tl, y);
  ctx.lineTo(x + w - tr, y);
  if (tr) ctx.quadraticCurveTo(x + w, y, x + w, y + tr); else ctx.lineTo(x + w, y);
  ctx.lineTo(x + w, y + h - br);
  if (br) ctx.quadraticCurveTo(x + w, y + h, x + w - br, y + h); else ctx.lineTo(x + w, y + h);
  ctx.lineTo(x + bl, y + h);
  if (bl) ctx.quadraticCurveTo(x, y + h, x, y + h - bl); else ctx.lineTo(x, y + h);
  ctx.lineTo(x, y + tl);
  if (tl) ctx.quadraticCurveTo(x, y, x + tl, y); else ctx.lineTo(x, y);
  ctx.closePath();
}
function fillRoundRectCorners(ctx, x, y, w, h, r, corners) {
  roundRectPath(ctx, x, y, w, h, r, corners);
  ctx.fill();
}

// ================== 2) ç‰ˆé¢è¨ˆç®— ==================
function getTeamCanvasWidth(team) {
  const basePad = 8;
  const innerGap = 4;
  const squadCount = Math.max(1, (team.squads ? team.squads.length : 0) || 6);
  const squadWidth = 100;
  return basePad * 2 + squadCount * squadWidth + (squadCount - 1) * innerGap;
}
function sortTeamsByPriority(teamsArr) {
  const order = { "é€²æ”»": 1, "æ‹†å¡”": 2, "æ©Ÿå‹•": 3, "é˜²å®ˆ": 4 };
  return [...teamsArr].sort((a, b) => (order[a.team] || 99) - (order[b.team] || 99));
}

// ================== 3) ä¸‹è¼‰åœ–ç‰‡ï¼ˆè¡Œå…§åœ˜éšŠç„¡æ°´å¹³é–“è·ï¼‰ ==================
function downloadThisWeekImage() {
  const data = getPanelData(thisWeekPanel);

  const tagOrder = ["ä¸€åœ˜","äºŒåœ˜","ä¸‰åœ˜","å››åœ˜"];
  const grouped = tagOrder
    .map(tag => ({ tag, teams: data.filter(t => (t.tag || "ä¸€åœ˜") === tag) }))
    .filter(g => g.teams.length > 0)
    .map(g => ({ tag: g.tag, teams: sortTeamsByPriority(g.teams) }));

  const teamBlockH = 272;
  const rowHeaderH = 30;
  const rowGapY = 30;
  const sidePad = 20;
  const topPad = 50;
  const titleH = 32;

  const rowWidths = grouped.map(group => {
    let w = 0;
    group.teams.forEach(team => { w += getTeamCanvasWidth(team); });
    return Math.max(420 - sidePad * 2, w);
  });

  const canvasWidth = Math.max(...rowWidths.map(w => w + sidePad * 2));
  const rowTotalH = rowHeaderH + teamBlockH;
  const canvasHeight =
    topPad + titleH + grouped.length * rowTotalH + (grouped.length - 1) * rowGapY + sidePad;

  const SCALE = 3;
  const canvas = document.createElement("canvas");
  canvas.width = canvasWidth * SCALE;
  canvas.height = canvasHeight * SCALE;
  const ctx = canvas.getContext("2d");
  ctx.scale(SCALE, SCALE);

  // èƒŒæ™¯èˆ‡æ¨™é¡Œ
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(0, 0, canvasWidth, canvasHeight);
  ctx.fillStyle = "#0f172a";
  ctx.font = "bold 22px system-ui";
  ctx.fillText("æœ¬é€±åå–®", sidePad, topPad);

  // é€è¡Œç¹ªè£½
  let currentY = topPad + titleH;
  grouped.forEach((group, rowIdx) => {
    const teamsTotalW = rowWidths[rowIdx];
    let x = sidePad;

    // åœ˜è™Ÿç°åº•ï¼ˆä¸Šåœ“ä¸‹ç›´ï¼‰
    const headerX = x, headerW = teamsTotalW, headerH = rowHeaderH;
    ctx.fillStyle = "#B4BBC8";
    fillRoundRectCorners(ctx, headerX, currentY, headerW, headerH, 8, { tl:true, tr:true, br:false, bl:false });

    // åœ˜è™Ÿæ–‡å­—
    ctx.fillStyle = "#0f172a";
    ctx.font = "bold 15px system-ui";
    const tagTextW = ctx.measureText(group.tag).width;
    ctx.fillText(group.tag, headerX + (headerW - tagTextW) / 2, currentY + headerH / 2 + 5);

    // åŒè¡Œåœ˜éšŠç„¡ç¸«æ’åˆ—
    let startIndex = 1;
    const teamTopY = currentY + headerH;
    group.teams.forEach(team => {
      const w = getTeamCanvasWidth(team);
      drawTeamBlockImage(ctx, team, x, teamTopY, w, teamBlockH, startIndex);
      const squadCount = Math.max(1, (team.squads ? team.squads.length : 0) || 6);
      startIndex += squadCount;
      x += w;
    });

    currentY += rowTotalH + rowGapY;
  });

  const link = document.createElement("a");
  link.download = "this-week.png";
  link.href = canvas.toDataURL("image/png");
  link.click();
}

// ================== 4) å–®ä¸€å¡ç‰‡ç¹ªè£½ï¼ˆåç¨±å¡ï¼‹æŠ€èƒ½å¡åˆ†é›¢ï¼Œçš†ç”¨ crisp é‚Šç·šï¼‰ ==================
function drawTeamBlockImage(ctx, team, x, y, w, h, startIndex) {
  // å¤–æ¡†ç™½å¡ç‰‡ï¼ˆå››è§’åœ“ï¼‰
  ctx.fillStyle = "#ffffff";
  fillRoundRectCorners(ctx, x, y, w, h, 12, {tl:true,tr:true,br:true,bl:true});
  strokeRoundedCrisp(ctx, x, y, w, h, 12, {tl:true,tr:true,br:true,bl:true}, "#e2e8f0");

  // é ‚éƒ¨åœ˜éšŠè‰²æ¢ï¼ˆç„¡åœ“è§’ï¼‰
  const headColor = teamColorByName(team.team);
  const HEAD_H = 30;
  ctx.fillStyle = headColor;
  ctx.fillRect(x, y, w, HEAD_H);

  // åœ˜éšŠåç¨±
  ctx.fillStyle = "#ffffff";
  ctx.font = "bold 15px system-ui";
  ctx.fillText(team.team, x + 12, y + Math.round(HEAD_H * 0.7));

  // å…§éƒ¨å°ºå¯¸
  const INNER_PAD = 8;
  const gap = 4;
  const squads = team.squads || [];
  const squadCount = Math.max(1, (squads.length || 6));
  const availW = w - INNER_PAD * 2 - gap * (squadCount - 1);
  const squadW  = availW / squadCount;
  const availH  = h - HEAD_H - INNER_PAD * 2;

  // é«˜åº¦é…ç½®ï¼ˆå¯è‡ªé©æ‡‰ï¼‰
  let TITLE_H  = 28; // å°éšŠæ¨™é¡Œï¼ˆå››è§’åœ“ç¨ç«‹å¡ï¼‰
  let NAME_H   = TITLE_H; // åç¨±å¡é«˜åº¦ï¼ˆä¸ŠåŠåœ“è§’ï¼‰
  let SKILL_H  = TITLE_H; // æŠ€èƒ½å¡é«˜åº¦ï¼ˆä¸‹åŠåœ“è§’ï¼‰
  let SP_TITLE = 6;       // æ¨™é¡Œèˆ‡ç¬¬ä¸€ä½ä¹‹é–“çš„è·é›¢
  let SPACER   = 6;       // æˆå“¡èˆ‡æˆå“¡ä¹‹é–“è·

  const totalNeed = TITLE_H + SP_TITLE + 6*(TITLE_H * 2) + 5*SPACER;
  if (totalNeed > availH) {
    const s = availH / totalNeed;
    TITLE_H  = Math.max(22, Math.floor(TITLE_H * s));
    NAME_H   = TITLE_H;
    SKILL_H  = TITLE_H;
  }

  for (let i = 0; i < squadCount; i++) {
    const sx = x + INNER_PAD + i * (squadW + gap);
    const sy = y + HEAD_H + INNER_PAD;

    // â‘  å°éšŠæ¨™é¡Œï¼ˆå››è§’åœ“ï¼Œç¨ç«‹å¡ï¼‰
    const titleX = sx + 2, titleY = sy + 2, titleW = squadW - 4;
    ctx.fillStyle = "#f8fafc";
    fillRoundRectCorners(ctx, titleX, titleY, titleW, TITLE_H, 8, {tl:true,tr:true,br:true,bl:true});
    strokeRoundedCrisp(ctx, titleX, titleY, titleW, TITLE_H, 8, {tl:true,tr:true,br:true,bl:true}, "#e2e8f0");
    ctx.fillStyle = "#0f172a";
    ctx.font = "bold 13px system-ui";
    ctx.fillText(`ç¬¬${startIndex + i}å°éšŠ`, titleX + 10, titleY + Math.round(TITLE_H * 0.7));

    // æ¨™é¡Œèˆ‡ç¬¬ä¸€ä½æˆå“¡ä¹‹é–“çš„ç©ºéš™ï¼ˆé¿å…æ®˜ç·šï¼‰
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(sx - 1, titleY + TITLE_H, squadW + 2, SP_TITLE);

    // â‘¡ æˆå“¡åˆ—ï¼ˆåç¨±å¡ï¼‹æŠ€èƒ½å¡åˆ†é›¢ï¼‰
    const squad = squads[i];
    let rowY = titleY + TITLE_H + SP_TITLE;

    for (let m = 0; m < 6; m++) {
      const nameBoxX = sx + 2;
      const nameBoxY = rowY;
      const nameBoxW = squadW - 4;
      const mem = (squad && squad.members[m]) ? squad.members[m] : null;

      // åç¨±å¡ï¼ˆä¸ŠåŠåœ“è§’ï¼Œç¨ç«‹å¡ï¼‰
      ctx.fillStyle = "#ffffff";
      fillRoundRectCorners(ctx, nameBoxX, nameBoxY, nameBoxW, NAME_H, 6, { tl:true, tr:true, br:false, bl:false });
      strokeRoundedCrisp(ctx, nameBoxX, nameBoxY, nameBoxW, NAME_H, 6, { tl:true, tr:true, br:false, bl:false }, "#e2e8f0");

      // å·¦å´è·æ¥­è‰²æ¢ + åç¨±æ–‡å­—
      if (mem && mem.name) {
        const jobColor = mem.job && roleColors[mem.job] ? darkenHex(roleColors[mem.job], 0.25) : "#0f172a";
        ctx.fillStyle = jobColor;
        ctx.fillRect(nameBoxX, nameBoxY, 5, NAME_H);
        ctx.fillStyle = jobColor;
        ctx.font = "bold 14px system-ui";
        ctx.fillText(mem.name, nameBoxX + 10, nameBoxY + Math.round(NAME_H * 0.75));
      }

      rowY += NAME_H; // æ¥è‘—ç•«æŠ€èƒ½å¡

      // æŠ€èƒ½å¡ï¼ˆä¸‹åŠåœ“è§’ï¼Œç¨ç«‹å¡ï¼‰
      const skillBoxX = sx + 2;
      const skillBoxY = rowY;
      const skillBoxW = squadW - 4;
      const hasSkill = !!(mem && mem.skill && mem.skill.trim());

      ctx.fillStyle = hasSkill ? "#FFFFDB" : "#ffffff";
      fillRoundRectCorners(ctx, skillBoxX, skillBoxY, skillBoxW, SKILL_H, 6, { tl:false, tr:false, br:true, bl:true });
      strokeRoundedCrisp(ctx, skillBoxX, skillBoxY, skillBoxW, SKILL_H, 6, { tl:false, tr:false, br:true, bl:true }, "#e2e8f0");

      if (hasSkill) {
        ctx.fillStyle = "#0f172a";
        ctx.font = "bold 12px system-ui";
        ctx.fillText(mem.skill, skillBoxX + 8, skillBoxY + Math.round(SKILL_H * 0.75));
      }
      rowY += SKILL_H;
      // æˆå“¡ä¹‹é–“çš„é–“è·
      if (m !== 5) {
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(sx - 1, rowY, squadW + 2, SPACER);
        rowY += SPACER;
      }
    }
  }
}
// ä»¥ä¸Šé€™æ®µ V14.7 å®Œæ•´ä¸‹è¼‰åœ–ç‰‡åŠŸèƒ½ï¼ˆåç¨±/æŠ€èƒ½å…©å¼µç¨ç«‹å¡ï¼‰
    

    function maybeOpenMemberPicker(e, input){ if (input.value.trim() === "") { openMemberPicker(input); } }
    function openMemberPicker(input){
      pickerTargetInput = input;
      const rect = input.getBoundingClientRect();
      memberPicker.style.left = (rect.left + window.scrollX) + "px";
      memberPicker.style.top = (rect.bottom + window.scrollY + 4) + "px";
      memberPicker.style.display = "block";
      pickerSearch.value = "";
      renderPickerList(allMembers);
      pickerSearch.focus();
    }
    function renderPickerList(list){
      pickerList.innerHTML = "";
      list.forEach(m=>{
        const item = document.createElement("div");
        item.className = "picker-item";
        item.textContent = m.name + (m.job? " ("+m.job+")": "");
        item.onclick = ()=>selectMemberFromPicker(m);
        pickerList.appendChild(item);
      });
    }
    function filterPickerList(){
      const kw = pickerSearch.value.trim();
      const list = allMembers.filter(m=>!kw || m.name.includes(kw) || (m.skill && m.skill.includes(kw)));
      renderPickerList(list);
    }

    function selectMemberFromPicker(m){
      if (!pickerTargetInput) return;
      thisWeekPanel.querySelectorAll("input[data-role='name']").forEach(inp => {
        if (inp !== pickerTargetInput && inp.value.trim() === m.name) {
          clearInputAndSkill(inp);
        }
      });
      pickerTargetInput.value = m.name;
      applyJobColor(pickerTargetInput, m.job);
      const skillRow = pickerTargetInput.parentElement.nextElementSibling;
      if (skillRow && skillRow.querySelector("input[data-role='skill']")) { setSkillInputValue(skillRow.querySelector("input[data-role='skill']"), m.skill || ""); }
      pickerTargetInput.dataset.dirty = "1";
      saveState();
      closeMemberPicker();
    }
    function closeMemberPicker(){ memberPicker.style.display = "none"; pickerTargetInput = null; }
    document.addEventListener("click", function(e){ if (!memberPicker.contains(e.target) && e.target !== pickerTargetInput) { closeMemberPicker(); } });

    function updateSkillColor(cell) {
      const skill = cell.querySelector(".skill");
      if (!skill) return;
      const text = (skill.textContent || "").trim();
      if (text) skill.style.background = "#fef9c3";
      else skill.style.background = "transparent";
    }

    async function loadState(){
      renderRoleTabs();
      renderMemberList();

      const loginStr = localStorage.getItem(LOGIN_STORAGE_KEY);
      if (loginStr) {
        try { const obj = JSON.parse(loginStr); currentUser = obj.user || null; lastLoginTime = obj.time || 0; } catch(e){}
      }

      const s = localStorage.getItem(STORAGE_KEY);
      if (s) {
        try { const localState = JSON.parse(s); applyStateToPage(localState, true); } catch(e){}
      }

      try {
        const res = await fetchWithTimeout(REMOTE_API + "?action=get", 3000);
        const data = await res.json();
        if (data && data.success && data.payload) {
          const currentLocal = localStorage.getItem(STORAGE_KEY);
          if (!currentLocal || !sameJSON(JSON.parse(currentLocal), data.payload)) {
            applyStateToPage(data.payload, false);
            localStorage.setItem(STORAGE_KEY, JSON.stringify(data.payload));
          }
          if (data.updatedAt) lastKnownUpdatedAt = data.updatedAt;
        }
      } catch(err){ console.warn("é›²ç«¯è®€å–é€¾æ™‚æˆ–å¤±æ•—", err); }

      startVersionWatcher();
    }

    loadState();
    loadPersistentIgnore();
    renderStuckList();
    // é¢æ¿èˆ‡æ›¿è£œå€ï¼šä»»ä½• input/change çš†è¦–ç‚ºç·¨è¼¯
    ["input","change"].forEach(evt=>{
    thisWeekPanel.addEventListener(evt, suppressOutlinesOnEdit, true);
    subsList.addEventListener(evt, suppressOutlinesOnEdit, true);
    });
    // æ‹–æ›³é–‹å§‹ä¹Ÿè¦–ç‚ºç·¨è¼¯ï¼ˆå³ä½¿å°šæœªæ”¾ä¸‹ï¼‰
    document.addEventListener("dragstart", suppressOutlinesOnEdit, true);

  </script>
</body>
</html>















